// arkanoid sineus 2024 @indoostrialniy

//-Wl,--subsystem,windows в командах сборки для отключения вывода в консоль

#include <iostream>
#include <map>
#include <fstream>  //ifstream
#include <vector>

#include <chrono>
using hr_clock = std::chrono::high_resolution_clock;
using hr_time_point = hr_clock::time_point;
using hr_duration = hr_clock::duration;
using milliseconds = std::chrono::milliseconds;

#include <thread>

#include "glm/glm.hpp"
#include "glm/gtc/quaternion.hpp"
#include "glm/gtx/intersect.hpp"
#include "glm/gtx/vector_angle.hpp"
#include "glm/gtc/random.hpp"

#define GLEW_STATIC
#include "GL/glew.h"
#include "GLFW/glfw3.h"

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_write.h"

#define printMessage(msg) //std::cout << msg << std::endl;
#define printVariable(var) //std::cout << (#var) << " " << var << std::endl;
#define printVarComment(msg, var) //std::cout << msg << " " << var << std::endl;

#define printVec2(vec) //std::cout << "\tXY   " << (#vec) << ": " << (vec.x) << " " << (vec.y) << std::endl; 
#define printVec3(vec) //std::cout << "\tXYZ  " << (#vec) << ": " << (vec.x) << " " << (vec.y) << " " << (vec.z) << std::endl; 
#define printVec4(vec) //std::cout << "\tXYZW " << (#vec) << ": " << (vec.x) << " " << (vec.y) << " " << (vec.z) << " " << (vec.w) << std::endl;
#define printQuat(vec) //std::cout << "\tXYZW " << (#vec) << ": " << (vec[0]) << " " << (vec[1]) << " " << (vec[2]) << " " << (vec[3]) << " " << std::endl;

#define printMat3(text, matrix) //std::cout << "\n" << (text) << " [" << (#matrix) << "] as though 3x3(maybe) transposed(!) " << std::endl; printVec3(matrix[0]) printVec3(matrix[1])  printVec3(matrix[2])
#define printMat4(text, matrix) //std::cout << "\n" << (text) << " [" << (#matrix) << "] as though 4x4(maybe) transposed(!) " << std::endl; printVec4(matrix[0]) printVec4(matrix[1])  printVec4(matrix[2])  printVec4(matrix[3]) 


//смена цвета при разбивании блока
//скорость растет по мере исчезновения блоков, для стабилизации динамики игры
//есть 1-2 "бомбы", взрывающие соседние блоки
//при пропуске мяча экран плавно заливается красным

//для картинки вычислять кватернион на основе матрицы lookAt, составленной по позиции и цели


glm::vec4 blendVectors4(glm::vec4 A, glm::vec4 B, float mix2)
{
	return A + glm::vec4(mix2 * (B[0] - A[0]), mix2 * (B[1] - A[1]), mix2 * (B[2] - A[2]), 1);
}

glm::quat blendQuat(glm::quat A, glm::quat B, float mix2)
{
	//return  glm::mix(A, B, mix2);
	return glm::slerp(A, B, mix2);
	//interpolated[0] = vec4(mix2.x, mix2.y, mix2.z, mix2.w);
}



std::string getOperationSystem()
{
#ifdef _WIN32
	return "Windows";
#elif __linux__
	return "Linux";
#else
	return "Unknown";
#endif
}


struct Banner_1024	//структура описания геометрии модели плоского баннера
{
	int vertices = 6;
	int faces = 2;
	
	
	float geometry[6*5] = {	// в данном массиве хранится описание геометрии пола: 36 вершин в формате position.xyz texCoord.uv
		0.500000, -0.500000, 0.000000, 1.000000, 0.000000,
		-0.500000, 0.500000, 0.000000, 0.000000, 1.000000,
		-0.500000, -0.500000, 0.000000, 0.000000, 0.000000,
		0.500000, -0.500000, 0.000000, 1.000000, 0.000000,
		0.500000, 0.500000, 0.000000, 1.000000, 1.000000,
		-0.500000, 0.500000, 0.000000, 0.000000, 1.000000
	};
};


struct Field_01	//структура описания геометрии модели игрового поля
{
	int vertices = 36;
	int faces = 12;
	
	
	float geometry[36*5] = {	// в данном массиве хранится описание геометрии пола: 36 вершин в формате position.xyz texCoord.uv
		-25.000000, -0.000001, 0.100000, 0.495800, 0.906200,
		-25.000000, 30.000000, -0.100000, 0.507500, 0.000000,
		-25.000000, -0.000001, -0.100000, 0.507500, 0.906200,
		-25.000000, 30.000000, 0.100000, 0.505800, 1.125000,
		25.000000, 30.000000, -0.100000, 0.517500, 0.000000,
		-25.000000, 30.000000, -0.100000, 0.517500, 1.125000,
		25.000000, 30.000000, 0.100000, 0.510800, 0.000000,
		25.000000, -0.000001, -0.100000, 0.499200, 0.906200,
		25.000000, 30.000000, -0.100000, 0.499200, 0.000000,
		25.000000, -0.000001, 0.100000, 0.514200, 0.000000,
		-25.000000, -0.000001, -0.100000, 0.502500, 1.125000,
		25.000000, -0.000001, -0.100000, 0.502500, 0.000000,
		25.000000, 30.000000, -0.100000, 0.000000, 1.812500,
		-25.000000, -0.000001, -0.100000, 2.250000, 0.000000,
		-25.000000, 30.000000, -0.100000, 2.250000, 1.812500,
		-25.000000, 30.000000, 0.100000, 1.114900, 1.319800,
		25.000000, -0.000001, 0.100000, 0.000000, 0.000000,
		25.000000, 30.000000, 0.100000, 1.114900, 0.000000,
		-25.000000, -0.000001, 0.100000, 0.495800, 0.906200,
		-25.000000, 30.000000, 0.100000, 0.495800, 0.000000,
		-25.000000, 30.000000, -0.100000, 0.507500, 0.000000,
		-25.000000, 30.000000, 0.100000, 0.505800, 1.125000,
		25.000000, 30.000000, 0.100000, 0.505800, 0.000000,
		25.000000, 30.000000, -0.100000, 0.517500, 0.000000,
		25.000000, 30.000000, 0.100000, 0.510800, 0.000000,
		25.000000, -0.000001, 0.100000, 0.510800, 0.906300,
		25.000000, -0.000001, -0.100000, 0.499200, 0.906200,
		25.000000, -0.000001, 0.100000, 0.514200, 0.000000,
		-25.000000, -0.000001, 0.100000, 0.514200, 1.125000,
		-25.000000, -0.000001, -0.100000, 0.502500, 1.125000,
		25.000000, 30.000000, -0.100000, 0.000000, 1.812500,
		25.000000, -0.000001, -0.100000, 0.000000, 0.000000,
		-25.000000, -0.000001, -0.100000, 2.250000, 0.000000,
		-25.000000, 30.000000, 0.100000, 1.114900, 1.319800,
		-25.000000, -0.000001, 0.100000, 0.000000, 1.319800,
		25.000000, -0.000001, 0.100000, 0.000000, 0.000000
	};
};


struct Wall_01	//структура описания геометрии модели стены
{
	int vertices = 36;
	int faces = 12;
	
	
	float geometry[36*5] = {	// в данном массиве хранится описание геометрии пола: 36 вершин в формате position.xyz texCoord.uv
		-7.500000, -0.050000, 0.500000, 0.076700, 0.033300,
		-7.500000, 0.050000, -0.500000, 0.073300, 0.000000,
		-7.500000, -0.050000, -0.500000, 0.076700, 0.000000,
		-7.500000, 0.050000, 0.500000, 0.000000, 1.000000,
		22.499998, 0.049998, -0.500000, 0.033300, 0.000000,
		-7.500000, 0.050000, -0.500000, 0.033300, 1.000000,
		22.499998, 0.049998, 0.500000, 0.076700, 0.066700,
		22.499998, -0.050002, -0.500000, 0.073300, 0.033300,
		22.499998, 0.049998, -0.500000, 0.076700, 0.033300,
		22.499998, -0.050002, 0.500000, 0.066700, 0.000000,
		-7.500000, -0.050000, -0.500000, 0.033300, 1.000000,
		22.499998, -0.050002, -0.500000, 0.033300, 0.000000,
		22.499998, 0.049998, -0.500000, 0.070000, 0.000000,
		-7.500000, -0.050000, -0.500000, 0.073300, 1.000000,
		-7.500000, 0.050000, -0.500000, 0.070000, 1.000000,
		-7.500000, 0.050000, 0.500000, 0.070000, 1.000000,
		22.499998, -0.050002, 0.500000, 0.066700, 0.000000,
		22.499998, 0.049998, 0.500000, 0.070000, 0.000000,
		-7.500000, -0.050000, 0.500000, 0.076700, 0.033300,
		-7.500000, 0.050000, 0.500000, 0.073300, 0.033300,
		-7.500000, 0.050000, -0.500000, 0.073300, 0.000000,
		-7.500000, 0.050000, 0.500000, 0.000000, 1.000000,
		22.499998, 0.049998, 0.500000, 0.000000, 0.000000,
		22.499998, 0.049998, -0.500000, 0.033300, 0.000000,
		22.499998, 0.049998, 0.500000, 0.076700, 0.066700,
		22.499998, -0.050002, 0.500000, 0.073300, 0.066700,
		22.499998, -0.050002, -0.500000, 0.073300, 0.033300,
		22.499998, -0.050002, 0.500000, 0.066700, 0.000000,
		-7.500000, -0.050000, 0.500000, 0.066700, 1.000000,
		-7.500000, -0.050000, -0.500000, 0.033300, 1.000000,
		22.499998, 0.049998, -0.500000, 0.070000, 0.000000,
		22.499998, -0.050002, -0.500000, 0.073300, 0.000000,
		-7.500000, -0.050000, -0.500000, 0.073300, 1.000000,
		-7.500000, 0.050000, 0.500000, 0.070000, 1.000000,
		-7.500000, -0.050000, 0.500000, 0.066700, 1.000000,
		22.499998, -0.050002, 0.500000, 0.066700, 0.000000
	};
};

struct Wall_02	//структура описания геометрии модели стены
{
	int vertices = 36;
	int faces = 12;
	
	
	float geometry[36*5] = {	// в данном массиве хранится описание геометрии пола: 36 вершин в формате position.xyz texCoord.uv
		-25.000002, -0.049999, 0.500000, 0.046000, 0.020000,
		-25.000002, 0.050001, -0.500000, 0.044000, 0.000000,
		-25.000002, -0.049999, -0.500000, 0.046000, 0.000000,
		-25.000002, 0.050001, 0.500000, 0.020000, 1.000000,
		24.999998, 0.049999, -0.500000, 0.040000, 0.000000,
		-25.000002, 0.050001, -0.500000, 0.040000, 1.000000,
		24.999998, 0.049999, 0.500000, 0.046000, 0.040000,
		24.999998, -0.050001, -0.500000, 0.044000, 0.020000,
		24.999998, 0.049999, -0.500000, 0.046000, 0.020000,
		24.999998, -0.050001, 0.500000, 0.020000, 0.000000,
		-25.000002, -0.049999, -0.500000, 0.000000, 1.000000,
		24.999998, -0.050001, -0.500000, 0.000000, 0.000000,
		24.999998, 0.049999, -0.500000, 0.042000, 0.000000,
		-25.000002, -0.049999, -0.500000, 0.044000, 1.000000,
		-25.000002, 0.050001, -0.500000, 0.042000, 1.000000,
		-25.000002, 0.050001, 0.500000, 0.042000, 1.000000,
		24.999998, -0.050001, 0.500000, 0.040000, 0.000000,
		24.999998, 0.049999, 0.500000, 0.042000, 0.000000,
		-25.000002, -0.049999, 0.500000, 0.046000, 0.020000,
		-25.000002, 0.050001, 0.500000, 0.044000, 0.020000,
		-25.000002, 0.050001, -0.500000, 0.044000, 0.000000,
		-25.000002, 0.050001, 0.500000, 0.020000, 1.000000,
		24.999998, 0.049999, 0.500000, 0.020000, 0.000000,
		24.999998, 0.049999, -0.500000, 0.040000, 0.000000,
		24.999998, 0.049999, 0.500000, 0.046000, 0.040000,
		24.999998, -0.050001, 0.500000, 0.044000, 0.040000,
		24.999998, -0.050001, -0.500000, 0.044000, 0.020000,
		24.999998, -0.050001, 0.500000, 0.020000, 0.000000,
		-25.000002, -0.049999, 0.500000, 0.020000, 1.000000,
		-25.000002, -0.049999, -0.500000, 0.000000, 1.000000,
		24.999998, 0.049999, -0.500000, 0.042000, 0.000000,
		24.999998, -0.050001, -0.500000, 0.044000, 0.000000,
		-25.000002, -0.049999, -0.500000, 0.044000, 1.000000,
		-25.000002, 0.050001, 0.500000, 0.042000, 1.000000,
		-25.000002, -0.049999, 0.500000, 0.040000, 1.000000,
		24.999998, -0.050001, 0.500000, 0.040000, 0.000000
	};
};

struct Carriage_01	//структура описания геометрии модели каретки
{
	int vertices = 132;
	int faces = 44;
	
	
	float geometry[132*5] = {	// в данном массиве хранится описание геометрии пола: 36 вершин в формате position.xyz texCoord.uv
		1.400000, -0.500000, 0.900000, 0.253300, 0.030200,
		-1.400000, -0.500000, 0.100000, 0.851300, 0.201000,
		1.400000, -0.500000, 0.100000, 0.253300, 0.201000,
		1.500000, 0.400000, 0.900000, 0.026200, 0.000000,
		1.500000, -0.400000, 0.100000, 0.197000, 0.170800,
		1.500000, 0.400000, 0.100000, 0.026200, 0.170800,
		-1.400000, 0.400000, 1.000000, 0.253300, 0.659500,
		1.400000, -0.400000, 1.000000, 0.851300, 0.488600,
		1.400000, 0.400000, 1.000000, 0.851300, 0.659500,
		-1.500000, -0.400000, 0.900000, 0.197000, 1.000000,
		-1.500000, 0.400000, 0.100000, 0.026200, 0.829200,
		-1.500000, -0.400000, 0.100000, 0.197000, 0.829200,
		-1.400000, 0.500000, 0.900000, 0.851300, 0.432300,
		1.400000, 0.500000, 0.100000, 0.253300, 0.261400,
		-1.400000, 0.500000, 0.100000, 0.851300, 0.261400,
		-1.400000, -0.400000, 0.000000, 0.197000, 0.799000,
		-1.400000, -0.500000, 0.100000, 0.223100, 0.814100,
		-1.500000, -0.400000, 0.100000, 0.197000, 0.829200,
		-1.400000, -0.500000, 0.900000, 0.238200, 0.462500,
		-1.400000, -0.400000, 1.000000, 0.253300, 0.488600,
		-1.500000, -0.400000, 0.900000, 0.223100, 0.488600,
		-1.400000, 0.400000, 0.000000, 0.026200, 0.799000,
		-1.500000, 0.400000, 0.100000, 0.026200, 0.829200,
		-1.400000, 0.500000, 0.100000, 0.000000, 0.814100,
		-1.400000, 0.400000, 1.000000, 0.253300, 0.659500,
		-1.400000, 0.500000, 0.900000, 0.238200, 0.685600,
		-1.500000, 0.400000, 0.900000, 0.223100, 0.659500,
		1.400000, -0.400000, 0.000000, 0.197000, 0.201000,
		1.500000, -0.400000, 0.100000, 0.197000, 0.170800,
		1.400000, -0.500000, 0.100000, 0.223100, 0.185900,
		1.400000, -0.400000, 1.000000, 0.851300, 0.488600,
		1.400000, -0.500000, 0.900000, 0.866400, 0.462500,
		1.500000, -0.400000, 0.900000, 0.881500, 0.488600,
		1.400000, 0.400000, 0.000000, 0.026200, 0.201000,
		1.400000, 0.500000, 0.100000, 0.000000, 0.185900,
		1.500000, 0.400000, 0.100000, 0.026200, 0.170800,
		1.400000, 0.400000, 1.000000, 0.851300, 0.659500,
		1.500000, 0.400000, 0.900000, 0.881500, 0.659500,
		1.400000, 0.500000, 0.900000, 0.866400, 0.685600,
		-1.400000, -0.400000, 0.000000, 0.197000, 0.799000,
		-1.500000, 0.400000, 0.100000, 0.026200, 0.829200,
		-1.400000, 0.400000, 0.000000, 0.026200, 0.799000,
		-1.400000, -0.500000, 0.900000, 0.851300, 0.030200,
		-1.500000, -0.400000, 0.100000, 0.881500, 0.201000,
		-1.400000, -0.500000, 0.100000, 0.851300, 0.201000,
		-1.400000, 0.400000, 1.000000, 0.253300, 0.659500,
		-1.500000, -0.400000, 0.900000, 0.223100, 0.488600,
		-1.400000, -0.400000, 1.000000, 0.253300, 0.488600,
		-1.400000, 0.500000, 0.100000, 0.851300, 0.261400,
		-1.500000, 0.400000, 0.900000, 0.881500, 0.432300,
		-1.400000, 0.500000, 0.900000, 0.851300, 0.432300,
		-1.400000, 0.400000, 0.000000, 0.851300, 0.231200,
		1.400000, 0.500000, 0.100000, 0.253300, 0.261400,
		1.400000, 0.400000, 0.000000, 0.253300, 0.231200,
		1.400000, 0.400000, 1.000000, 0.253300, 0.462500,
		-1.400000, 0.500000, 0.900000, 0.851300, 0.432300,
		-1.400000, 0.400000, 1.000000, 0.851300, 0.462500,
		1.500000, 0.400000, 0.100000, 0.223100, 0.261400,
		1.400000, 0.500000, 0.900000, 0.253300, 0.432300,
		1.500000, 0.400000, 0.900000, 0.223100, 0.432300,
		1.400000, 0.400000, 0.000000, 0.026200, 0.201000,
		1.500000, -0.400000, 0.100000, 0.197000, 0.170800,
		1.400000, -0.400000, 0.000000, 0.197000, 0.201000,
		1.400000, -0.400000, 1.000000, 0.851300, 0.488600,
		1.500000, 0.400000, 0.900000, 0.881500, 0.659500,
		1.400000, 0.400000, 1.000000, 0.851300, 0.659500,
		1.400000, -0.500000, 0.100000, 0.253300, 0.201000,
		1.500000, -0.400000, 0.900000, 0.223100, 0.030200,
		1.400000, -0.500000, 0.900000, 0.253300, 0.030200,
		1.400000, -0.400000, 0.000000, 0.253300, 0.231200,
		-1.400000, -0.500000, 0.100000, 0.851300, 0.201000,
		-1.400000, -0.400000, 0.000000, 0.851300, 0.231200,
		-1.400000, -0.400000, 1.000000, 0.851300, 0.000000,
		1.400000, -0.500000, 0.900000, 0.253300, 0.030200,
		1.400000, -0.400000, 1.000000, 0.253300, 0.000000,
		1.400000, 0.400000, 0.000000, 0.026200, 0.201000,
		-1.400000, -0.400000, 0.000000, 0.197000, 0.799000,
		-1.400000, 0.400000, 0.000000, 0.026200, 0.799000,
		1.400000, -0.500000, 0.900000, 0.253300, 0.030200,
		-1.400000, -0.500000, 0.900000, 0.851300, 0.030200,
		-1.400000, -0.500000, 0.100000, 0.851300, 0.201000,
		1.500000, 0.400000, 0.900000, 0.026200, 0.000000,
		1.500000, -0.400000, 0.900000, 0.197000, 0.000000,
		1.500000, -0.400000, 0.100000, 0.197000, 0.170800,
		-1.400000, 0.400000, 1.000000, 0.253300, 0.659500,
		-1.400000, -0.400000, 1.000000, 0.253300, 0.488600,
		1.400000, -0.400000, 1.000000, 0.851300, 0.488600,
		-1.500000, -0.400000, 0.900000, 0.197000, 1.000000,
		-1.500000, 0.400000, 0.900000, 0.026200, 1.000000,
		-1.500000, 0.400000, 0.100000, 0.026200, 0.829200,
		-1.400000, 0.500000, 0.900000, 0.851300, 0.432300,
		1.400000, 0.500000, 0.900000, 0.253300, 0.432300,
		1.400000, 0.500000, 0.100000, 0.253300, 0.261400,
		-1.400000, -0.400000, 0.000000, 0.197000, 0.799000,
		-1.500000, -0.400000, 0.100000, 0.197000, 0.829200,
		-1.500000, 0.400000, 0.100000, 0.026200, 0.829200,
		-1.400000, -0.500000, 0.900000, 0.851300, 0.030200,
		-1.500000, -0.400000, 0.900000, 0.881500, 0.030200,
		-1.500000, -0.400000, 0.100000, 0.881500, 0.201000,
		-1.400000, 0.400000, 1.000000, 0.253300, 0.659500,
		-1.500000, 0.400000, 0.900000, 0.223100, 0.659500,
		-1.500000, -0.400000, 0.900000, 0.223100, 0.488600,
		-1.400000, 0.500000, 0.100000, 0.851300, 0.261400,
		-1.500000, 0.400000, 0.100000, 0.881500, 0.261400,
		-1.500000, 0.400000, 0.900000, 0.881500, 0.432300,
		-1.400000, 0.400000, 0.000000, 0.851300, 0.231200,
		-1.400000, 0.500000, 0.100000, 0.851300, 0.261400,
		1.400000, 0.500000, 0.100000, 0.253300, 0.261400,
		1.400000, 0.400000, 1.000000, 0.253300, 0.462500,
		1.400000, 0.500000, 0.900000, 0.253300, 0.432300,
		-1.400000, 0.500000, 0.900000, 0.851300, 0.432300,
		1.500000, 0.400000, 0.100000, 0.223100, 0.261400,
		1.400000, 0.500000, 0.100000, 0.253300, 0.261400,
		1.400000, 0.500000, 0.900000, 0.253300, 0.432300,
		1.400000, 0.400000, 0.000000, 0.026200, 0.201000,
		1.500000, 0.400000, 0.100000, 0.026200, 0.170800,
		1.500000, -0.400000, 0.100000, 0.197000, 0.170800,
		1.400000, -0.400000, 1.000000, 0.851300, 0.488600,
		1.500000, -0.400000, 0.900000, 0.881500, 0.488600,
		1.500000, 0.400000, 0.900000, 0.881500, 0.659500,
		1.400000, -0.500000, 0.100000, 0.253300, 0.201000,
		1.500000, -0.400000, 0.100000, 0.223100, 0.201000,
		1.500000, -0.400000, 0.900000, 0.223100, 0.030200,
		1.400000, -0.400000, 0.000000, 0.253300, 0.231200,
		1.400000, -0.500000, 0.100000, 0.253300, 0.201000,
		-1.400000, -0.500000, 0.100000, 0.851300, 0.201000,
		-1.400000, -0.400000, 1.000000, 0.851300, 0.000000,
		-1.400000, -0.500000, 0.900000, 0.851300, 0.030200,
		1.400000, -0.500000, 0.900000, 0.253300, 0.030200,
		1.400000, 0.400000, 0.000000, 0.026200, 0.201000,
		1.400000, -0.400000, 0.000000, 0.197000, 0.201000,
		-1.400000, -0.400000, 0.000000, 0.197000, 0.799000
	};
};



struct Block_01	//структура описания геометрии модели кусочка блока
{
	int vertices = 108;
	int faces = 36;
	
	
	float geometry[108*5] = {	// в данном массиве хранится описание геометрии пола: 36 вершин в формате position.xyz texCoord.uv
		-0.058779, 0.319707, 0.279272, 0.000000, 0.000000,
		-0.118486, -0.176628, 0.281308, 1.000000, 0.091700,
		-0.054823, 0.322239, 0.281257, 1.000000, 1.000000,
		-0.054823, 0.322239, 0.281257, 1.000000, 1.000000,
		0.343749, -0.176628, 0.281289, 0.839500, 0.091800,
		0.393391, -0.126986, 0.281247, 1.000000, 0.182200,
		0.393391, -0.126986, 0.281247, 0.182200, 0.182200,
		0.443749, 0.266441, 0.226022, 1.000000, 0.091000,
		-0.054823, 0.322239, 0.281257, 1.000000, 1.000000,
		-0.000218, 0.316191, -0.217312, 0.091400, 0.000000,
		-0.058779, 0.319707, 0.279272, 1.000000, 0.000000,
		-0.054823, 0.322239, 0.281257, 1.000000, 1.000000,
		-0.058779, 0.319707, 0.279272, 1.000000, 1.000000,
		-0.000218, 0.316191, -0.217312, 0.091400, 0.091400,
		-0.442349, -0.076628, -0.217312, 0.814900, 0.091000,
		-0.488890, -0.110534, -0.150766, 0.212700, 0.212700,
		-0.505521, -0.127357, -0.067766, 1.000000, 0.181700,
		-0.058779, 0.319707, 0.279272, 1.000000, 1.000000,
		-0.456251, -0.176628, -0.018559, 0.296700, 0.091700,
		-0.058779, 0.319707, 0.279272, 1.000000, 1.000000,
		-0.505521, -0.127357, -0.067766, 0.181700, 0.181700,
		0.343749, -0.176628, -0.117312, 0.321500, 0.418200,
		-0.118486, -0.176628, 0.281308, 0.163700, 0.554300,
		-0.456251, -0.176628, -0.117312, 0.048300, 0.418200,
		0.443749, -0.076628, -0.117312, 0.726800, 0.000000,
		0.443749, 0.266441, 0.226022, 0.843900, 0.117300,
		0.443749, -0.076628, 0.268702, 0.726800, 0.131800,
		-0.456251, -0.176628, -0.117312, 0.726800, 0.715500,
		-0.488890, -0.110534, -0.150766, 0.699100, 0.715400,
		-0.456251, -0.087737, -0.206203, 0.689600, 0.694100,
		0.343749, -0.076628, -0.217312, 0.684900, 0.418200,
		0.443749, -0.076628, -0.117312, 0.684900, 0.369800,
		0.343749, -0.176628, -0.117312, 0.726800, 0.394000,
		-0.456251, -0.176628, -0.117312, 0.048300, 0.418200,
		-0.505521, -0.127357, -0.067766, 0.024500, 0.435100,
		-0.505567, -0.127311, -0.117312, 0.024500, 0.418200,
		0.343749, -0.076628, -0.217312, 0.684900, 0.418200,
		0.443749, 0.266864, -0.117312, 0.567600, 0.369800,
		0.443749, -0.076628, -0.117312, 0.684900, 0.369800,
		0.443749, -0.076628, -0.117312, 0.369800, 0.418200,
		0.393391, -0.126986, 0.281247, 0.345500, 0.554300,
		0.343749, -0.176628, -0.117312, 0.321500, 0.418200,
		-0.456251, -0.176628, -0.117312, 0.048300, 0.418200,
		-0.442349, -0.076628, -0.217312, 0.053100, 0.369800,
		0.343749, -0.176628, -0.117312, 0.321500, 0.418200,
		-0.000218, 0.316191, -0.217312, 0.550700, 0.535500,
		0.343749, -0.076628, -0.217312, 0.684900, 0.418200,
		-0.442349, -0.076628, -0.217312, 0.684900, 0.686600,
		0.443749, 0.266441, 0.226022, 0.091000, 0.091000,
		0.343749, 0.278132, -0.217312, 0.295800, 0.091300,
		-0.054823, 0.322239, 0.281257, 1.000000, 1.000000,
		-0.054823, 0.322239, 0.281257, 1.000000, 1.000000,
		-0.118486, -0.176628, 0.281308, 0.091700, 0.091700,
		0.343749, -0.176628, 0.281289, 0.839500, 0.091800,
		0.393391, -0.126986, 0.281247, 0.182200, 0.182200,
		0.443749, -0.076628, 0.268702, 0.297000, 0.090500,
		0.443749, 0.266441, 0.226022, 1.000000, 0.091000,
		-0.456251, -0.087737, -0.206203, 0.855900, 0.111300,
		-0.488890, -0.110534, -0.150766, 1.000000, 0.212700,
		-0.442349, -0.076628, -0.217312, 0.814900, 0.091000,
		-0.488890, -0.110534, -0.150766, 1.000000, 0.212700,
		-0.058779, 0.319707, 0.279272, 1.000000, 1.000000,
		-0.442349, -0.076628, -0.217312, 0.814900, 0.091000,
		-0.488890, -0.110534, -0.150766, 0.212700, 0.212700,
		-0.505567, -0.127311, -0.117312, 0.593600, 0.181900,
		-0.505521, -0.127357, -0.067766, 1.000000, 0.181700,
		-0.456251, -0.176628, -0.018559, 0.296700, 0.091700,
		-0.118486, -0.176628, 0.281308, 1.000000, 0.092100,
		-0.058779, 0.319707, 0.279272, 1.000000, 1.000000,
		0.343749, -0.176628, 0.281289, 0.321500, 0.554300,
		-0.118486, -0.176628, 0.281308, 0.163700, 0.554300,
		0.343749, -0.176628, -0.117312, 0.321500, 0.418200,
		-0.118486, -0.176628, 0.281308, 0.163700, 0.554300,
		-0.456251, -0.176628, -0.018559, 0.048300, 0.451900,
		-0.456251, -0.176628, -0.117312, 0.048300, 0.418200,
		0.443749, -0.076628, -0.117312, 0.726800, 0.000000,
		0.443749, 0.266864, -0.117312, 0.844100, 0.000000,
		0.443749, 0.266441, 0.226022, 0.843900, 0.117300,
		-0.456251, -0.176628, -0.117312, 0.726800, 0.715500,
		-0.505567, -0.127311, -0.117312, 0.706100, 0.727500,
		-0.488890, -0.110534, -0.150766, 0.699100, 0.715400,
		-0.456251, -0.176628, -0.117312, 0.048300, 0.418200,
		-0.456251, -0.176628, -0.018559, 0.048300, 0.451900,
		-0.505521, -0.127357, -0.067766, 0.024500, 0.435100,
		0.343749, -0.076628, -0.217312, 0.684900, 0.418200,
		0.343749, 0.278132, -0.217312, 0.563800, 0.418200,
		0.443749, 0.266864, -0.117312, 0.567600, 0.369800,
		0.443749, -0.076628, 0.268702, 0.369800, 0.550000,
		0.393391, -0.126986, 0.281247, 0.345500, 0.554300,
		0.443749, -0.076628, -0.117312, 0.369800, 0.418200,
		0.393391, -0.126986, 0.281247, 0.345500, 0.554300,
		0.343749, -0.176628, 0.281289, 0.321500, 0.554300,
		0.343749, -0.176628, -0.117312, 0.321500, 0.418200,
		-0.456251, -0.087737, -0.206203, 0.048300, 0.375200,
		-0.442349, -0.076628, -0.217312, 0.053100, 0.369800,
		-0.456251, -0.176628, -0.117312, 0.048300, 0.418200,
		-0.442349, -0.076628, -0.217312, 0.053100, 0.369800,
		0.343749, -0.076628, -0.217312, 0.321500, 0.369800,
		0.343749, -0.176628, -0.117312, 0.321500, 0.418200,
		-0.000218, 0.316191, -0.217312, 0.550700, 0.535500,
		0.343749, 0.278132, -0.217312, 0.563800, 0.418200,
		0.343749, -0.076628, -0.217312, 0.684900, 0.418200,
		0.443749, 0.266864, -0.117312, 0.794600, 0.090900,
		0.343749, 0.278132, -0.217312, 0.295800, 0.091300,
		0.443749, 0.266441, 0.226022, 0.091000, 0.091000,
		0.343749, 0.278132, -0.217312, 0.295800, 0.091300,
		-0.000218, 0.316191, -0.217312, 1.000000, 0.091100,
		-0.054823, 0.322239, 0.281257, 1.000000, 1.000000
	};
};

struct Block_02	//структура описания геометрии модели кусочка блока
{
	int vertices = 84;
	int faces = 28;
	
	
	float geometry[84*5] = {	// в данном массиве хранится описание геометрии пола: 36 вершин в формате position.xyz texCoord.uv
		-0.191369, -0.501031, -0.143956, 0.821000, 0.729200,
		0.197310, -0.100488, 0.353520, 1.000000, 0.000000,
		-0.235922, -0.531417, -0.079372, 1.000000, 0.789200,
		-0.235922, -0.531417, -0.079372, 0.789200, 0.789200,
		0.197310, -0.100488, 0.353520, 0.000000, 0.000000,
		0.197320, -0.090541, 0.354155, 1.000000, 0.000000,
		0.197320, -0.090541, 0.354155, 1.000000, 0.000000,
		0.253144, 0.298969, -0.143956, 0.272000, 0.181100,
		0.247554, 0.349727, -0.093199, 0.183400, 0.000000,
		0.197310, -0.100488, 0.353520, 1.000000, 0.000000,
		0.252698, -0.106321, -0.143956, 0.908300, 0.908300,
		0.197320, -0.090541, 0.354155, 0.000000, 0.000000,
		0.247554, 0.349727, -0.093199, 0.183400, 0.183400,
		0.203239, 0.398969, 0.299200, 1.000000, 0.092100,
		0.197320, -0.090541, 0.354155, 1.000000, 1.000000,
		0.197320, -0.090541, 0.354155, 1.000000, 1.000000,
		0.203239, 0.398969, 0.299200, 0.092100, 0.092100,
		0.143142, 0.398969, 0.299567, 1.000000, 0.091800,
		0.241968, 0.398969, -0.043956, 0.321500, 0.170000,
		0.143142, 0.398969, 0.299567, 0.204200, 0.203800,
		0.203239, 0.398969, 0.299200, 0.204300, 0.183200,
		-0.201724, -0.509318, -0.135669, 0.688400, 0.693400,
		-0.251109, -0.501031, -0.094572, 0.684900, 0.715300,
		-0.201724, -0.501031, -0.143956, 0.684900, 0.691400,
		-0.201724, 0.298969, -0.143956, 0.411700, 0.691400,
		-0.251078, 0.298969, -0.094602, 0.411700, 0.715200,
		-0.201724, 0.397634, -0.045292, 0.370400, 0.715200,
		-0.251078, 0.298969, -0.094602, 0.411700, 0.715200,
		-0.201724, -0.501031, -0.143956, 0.684900, 0.691400,
		-0.251109, -0.501031, -0.094572, 0.684900, 0.715300,
		0.247554, 0.349727, -0.093199, 0.345300, 0.168100,
		-0.201724, 0.298969, -0.143956, 0.369800, 0.321500,
		-0.201724, 0.397634, -0.045292, 0.321500, 0.321100,
		-0.201724, -0.509318, -0.135669, 0.048300, 0.373900,
		-0.201724, -0.501031, -0.143956, 0.048300, 0.369800,
		-0.191369, -0.501031, -0.143956, 0.051800, 0.369800,
		-0.201724, 0.298969, -0.143956, 0.411700, 0.691400,
		0.253144, 0.298969, -0.143956, 0.411700, 0.536000,
		0.252698, -0.106321, -0.143956, 0.550100, 0.536200,
		0.197320, -0.090541, 0.354155, 1.000000, 1.000000,
		0.143142, 0.398969, 0.299567, 0.091800, 0.091800,
		-0.251078, 0.298969, -0.094602, 0.819200, 0.047700,
		-0.235922, -0.531417, -0.079372, 1.000000, 0.789200,
		-0.201724, -0.509318, -0.135669, 0.851600, 0.744700,
		-0.191369, -0.501031, -0.143956, 0.821000, 0.729200,
		-0.191369, -0.501031, -0.143956, 0.821000, 0.729200,
		0.252698, -0.106321, -0.143956, 0.091800, 0.000000,
		0.197310, -0.100488, 0.353520, 1.000000, 0.000000,
		0.197320, -0.090541, 0.354155, 1.000000, 0.000000,
		0.252698, -0.106321, -0.143956, 1.000000, 0.908300,
		0.253144, 0.298969, -0.143956, 0.272000, 0.181100,
		0.247554, 0.349727, -0.093199, 0.183400, 0.183400,
		0.241968, 0.398969, -0.043956, 0.295800, 0.092000,
		0.203239, 0.398969, 0.299200, 1.000000, 0.092100,
		0.241968, 0.398969, -0.043956, 0.321500, 0.170000,
		-0.201724, 0.397634, -0.045292, 0.321500, 0.321100,
		0.143142, 0.398969, 0.299567, 0.204200, 0.203800,
		-0.201724, -0.509318, -0.135669, 0.688400, 0.693400,
		-0.235922, -0.531417, -0.079372, 0.697600, 0.715300,
		-0.251109, -0.501031, -0.094572, 0.684900, 0.715300,
		-0.251078, 0.298969, -0.094602, 0.411700, 0.715200,
		-0.201724, 0.298969, -0.143956, 0.411700, 0.691400,
		-0.201724, -0.501031, -0.143956, 0.684900, 0.691400,
		-0.201724, 0.397634, -0.045292, 0.321500, 0.321100,
		0.241968, 0.398969, -0.043956, 0.321500, 0.170000,
		0.247554, 0.349727, -0.093199, 0.345300, 0.168100,
		0.247554, 0.349727, -0.093199, 0.345300, 0.168100,
		0.253144, 0.298969, -0.143956, 0.369800, 0.166200,
		-0.201724, 0.298969, -0.143956, 0.369800, 0.321500,
		0.252698, -0.106321, -0.143956, 0.550100, 0.536200,
		-0.191369, -0.501031, -0.143956, 0.684900, 0.687900,
		-0.201724, 0.298969, -0.143956, 0.411700, 0.691400,
		-0.191369, -0.501031, -0.143956, 0.684900, 0.687900,
		-0.201724, -0.501031, -0.143956, 0.684900, 0.691400,
		-0.201724, 0.298969, -0.143956, 0.411700, 0.691400,
		0.143142, 0.398969, 0.299567, 0.091800, 0.091800,
		-0.201724, 0.397634, -0.045292, 0.802200, 0.094700,
		-0.251078, 0.298969, -0.094602, 0.819200, 0.047700,
		-0.251078, 0.298969, -0.094602, 0.819200, 0.047700,
		-0.251109, -0.501031, -0.094572, 0.818300, 0.776500,
		0.197320, -0.090541, 0.354155, 1.000000, 1.000000,
		-0.251109, -0.501031, -0.094572, 0.818300, 0.776500,
		-0.235922, -0.531417, -0.079372, 0.790600, 0.790600,
		0.197320, -0.090541, 0.354155, 1.000000, 1.000000
	};
};

struct Block_03	//структура описания геометрии модели кусочка блока
{
	int vertices = 96;
	int faces = 32;
	
	float geometry[96*5] = {	// в данном массиве хранится описание геометрии пола: 36 вершин в формате position.xyz texCoord.uv
		0.152186, -0.216446, 0.153953, 0.091000, 0.000000,
		0.096924, -0.216464, -0.343737, 1.000000, 0.000000,
		0.528844, 0.216108, 0.088477, 1.000000, 0.789500,
		0.420670, 0.232082, 0.104400, 1.000000, 0.796400,
		0.096924, -0.216464, -0.343737, 0.000000, 0.000000,
		-0.403053, -0.134322, -0.261839, 1.000000, 0.045500,
		-0.403053, -0.134322, -0.261839, 0.045500, 0.045500,
		-0.303053, 0.231735, 0.104746, 0.796500, 0.136700,
		0.420670, 0.232082, 0.104400, 0.796400, 0.796400,
		0.083778, -0.216523, -0.343264, 1.000000, 0.000000,
		-0.303053, -0.216714, 0.153953, 0.256600, 0.165900,
		-0.354195, -0.216747, 0.102811, 0.184200, 0.000000,
		0.083778, -0.216523, -0.343264, 0.000000, 0.000000,
		0.096924, -0.216464, -0.343737, 1.000000, 0.000000,
		0.152186, -0.216446, 0.153953, 0.908900, 0.908900,
		-0.403053, -0.162124, -0.289560, 1.000000, 0.090800,
		0.096924, -0.216464, -0.343737, 1.000000, 1.000000,
		0.083778, -0.216523, -0.343264, 0.000000, 0.000000,
		-0.403053, -0.162124, -0.289560, 0.906900, 0.906900,
		0.083778, -0.216523, -0.343264, 0.000000, 0.000000,
		-0.403053, -0.216456, -0.289640, 0.907300, 0.000000,
		-0.354195, -0.216747, 0.102811, 1.000000, 0.815800,
		-0.403053, -0.216456, -0.289640, 0.092700, 0.000000,
		0.083778, -0.216523, -0.343264, 1.000000, 0.000000,
		-0.303053, 0.182529, 0.153953, 0.411700, 0.048300,
		0.152186, -0.216446, 0.153953, 0.548000, 0.203800,
		0.496947, 0.182529, 0.153953, 0.411700, 0.321500,
		-0.403053, -0.216701, 0.053953, 1.000000, 0.410100,
		-0.403053, -0.134322, -0.261839, 0.892100, 0.438300,
		-0.403053, -0.216456, -0.289640, 0.882600, 0.410200,
		-0.303053, 0.182529, 0.153953, 0.411700, 0.048300,
		-0.303053, 0.231735, 0.104746, 0.391100, 0.036400,
		-0.403053, 0.180932, 0.053953, 0.411700, 0.000000,
		0.496947, 0.232070, 0.104411, 0.391000, 0.333500,
		0.505372, 0.182529, 0.145528, 0.411700, 0.325600,
		0.528844, 0.216108, 0.088477, 0.397600, 0.345100,
		-0.403053, 0.180932, 0.053953, 0.412200, 0.000000,
		-0.403053, -0.216701, 0.053953, 0.548000, 0.000000,
		-0.354195, -0.216747, 0.102811, 0.548100, 0.023600,
		0.496947, 0.182529, 0.153953, 0.000000, 0.048300,
		0.496947, 0.232070, 0.104411, 0.023900, 0.048300,
		0.420670, 0.232082, 0.104400, 0.023900, 0.074400,
		0.496947, 0.182529, 0.153953, 0.411700, 0.321500,
		0.496947, 0.171983, 0.153953, 0.415300, 0.321500,
		0.505372, 0.182529, 0.145528, 0.411700, 0.325600,
		0.528844, 0.216108, 0.088477, 1.000000, 0.789500,
		0.505372, 0.182529, 0.145528, 0.834500, 0.728300,
		0.496947, 0.171983, 0.153953, 0.799900, 0.709000,
		0.496947, 0.171983, 0.153953, 0.799900, 0.709000,
		0.152186, -0.216446, 0.153953, 0.091000, 0.000000,
		0.528844, 0.216108, 0.088477, 1.000000, 0.789500,
		0.420670, 0.232082, 0.104400, 1.000000, 0.796400,
		0.496947, 0.232070, 0.104411, 0.888600, 0.810100,
		0.528844, 0.216108, 0.088477, 0.789500, 0.789500,
		0.528844, 0.216108, 0.088477, 0.789500, 0.789500,
		0.096924, -0.216464, -0.343737, 0.000000, 0.000000,
		0.420670, 0.232082, 0.104400, 1.000000, 0.796400,
		0.096924, -0.216464, -0.343737, 0.000000, 0.000000,
		-0.403053, -0.162124, -0.289560, 0.909200, 0.000000,
		-0.403053, -0.134322, -0.261839, 1.000000, 0.045500,
		-0.403053, -0.134322, -0.261839, 0.045500, 0.045500,
		-0.403053, 0.180932, 0.053953, 0.695600, 0.047000,
		-0.303053, 0.231735, 0.104746, 0.796500, 0.136700,
		0.083778, -0.216523, -0.343264, 1.000000, 0.000000,
		0.152186, -0.216446, 0.153953, 1.000000, 0.908900,
		-0.303053, -0.216714, 0.153953, 0.256600, 0.165900,
		-0.354195, -0.216747, 0.102811, 1.000000, 0.815800,
		-0.403053, -0.216701, 0.053953, 0.797700, 0.704600,
		-0.403053, -0.216456, -0.289640, 0.092700, 0.000000,
		-0.303053, -0.216714, 0.153953, 0.548000, 0.048300,
		0.152186, -0.216446, 0.153953, 0.548000, 0.203800,
		-0.303053, 0.182529, 0.153953, 0.411700, 0.048300,
		0.152186, -0.216446, 0.153953, 0.548000, 0.203800,
		0.496947, 0.171983, 0.153953, 0.415300, 0.321500,
		0.496947, 0.182529, 0.153953, 0.411700, 0.321500,
		-0.403053, 0.180932, 0.053953, 1.000000, 0.545900,
		-0.403053, -0.134322, -0.261839, 0.892100, 0.438300,
		-0.403053, -0.216701, 0.053953, 1.000000, 0.410100,
		-0.403053, -0.134322, -0.261839, 0.892100, 0.438300,
		-0.403053, -0.162124, -0.289560, 0.882700, 0.428800,
		-0.403053, -0.216456, -0.289640, 0.882600, 0.410200,
		0.496947, 0.232070, 0.104411, 0.391000, 0.333500,
		0.496947, 0.182529, 0.153953, 0.411700, 0.321500,
		0.505372, 0.182529, 0.145528, 0.411700, 0.325600,
		-0.354195, -0.216747, 0.102811, 0.548100, 0.023600,
		-0.303053, -0.216714, 0.153953, 0.548000, 0.048300,
		-0.303053, 0.182529, 0.153953, 0.411700, 0.048300,
		-0.303053, 0.182529, 0.153953, 0.411700, 0.048300,
		-0.403053, 0.180932, 0.053953, 0.412200, 0.000000,
		-0.354195, -0.216747, 0.102811, 0.548100, 0.023600,
		0.420670, 0.232082, 0.104400, 0.023900, 0.074400,
		-0.303053, 0.231735, 0.104746, 0.023800, 0.321500,
		-0.303053, 0.182529, 0.153953, 0.000000, 0.321500,
		-0.303053, 0.182529, 0.153953, 0.000000, 0.321500,
		0.496947, 0.182529, 0.153953, 0.000000, 0.048300,
		0.420670, 0.232082, 0.104400, 0.023900, 0.074400
	};
};

struct Block_04	//структура описания геометрии модели кусочка блока
{
	int vertices = 102;
	int faces = 34;
	
	
	float geometry[102*5] = {	// в данном массиве хранится описание геометрии пола: 36 вершин в формате position.xyz texCoord.uv
		-0.123592, 0.333522, 0.220579, 0.896600, 0.306500,
		0.262862, 0.433522, 0.160099, 0.102800, 0.102800,
		-0.023592, 0.433522, 0.195692, 0.691300, 0.102000,
		0.374395, -0.066562, 0.208138, 1.000000, 0.000000,
		-0.123592, -0.010775, 0.263445, 1.000000, 0.908100,
		-0.123592, -0.066434, 0.262994, 0.091200, 0.000000,
		0.374395, -0.066562, 0.208138, 0.000000, 0.000000,
		0.318537, 0.433522, 0.153143, 0.908700, 0.000000,
		0.262862, 0.433522, 0.160099, 1.000000, 0.102800,
		-0.057314, 0.366890, -0.223658, 0.788400, 0.000000,
		0.318537, 0.433522, 0.153143, 0.908700, 0.908700,
		0.374395, -0.066562, 0.208138, 0.000000, 0.000000,
		-0.057757, -0.499267, -0.223794, 0.213100, 0.000000,
		-0.074504, -0.515566, -0.141346, 1.000000, 0.817000,
		-0.074396, -0.515674, -0.190748, 0.592200, 0.409300,
		0.369561, -0.072312, 0.204279, 0.000000, 0.000000,
		-0.123592, -0.466478, -0.092412, 0.907500, 0.728700,
		-0.074504, -0.515566, -0.141346, 0.817000, 0.817000,
		0.369561, -0.072312, 0.204279, 0.000000, 0.000000,
		0.374395, -0.066562, 0.208138, 1.000000, 0.000000,
		-0.123592, -0.066434, 0.262994, 0.907900, 0.907900,
		0.369561, -0.072312, 0.204279, 0.000000, 0.000000,
		-0.057757, -0.499267, -0.223794, 1.000000, 0.211200,
		0.374395, -0.066562, 0.208138, 1.000000, 1.000000,
		-0.073999, 0.333522, -0.240341, 0.954400, 0.181100,
		0.374395, -0.066562, 0.208138, 1.000000, 1.000000,
		-0.074045, -0.466478, -0.240295, 0.226000, 0.181500,
		-0.123592, 0.333522, -0.190748, 0.726800, 0.546500,
		-0.123592, -0.466478, -0.190748, 0.726800, 0.273200,
		-0.123592, -0.466478, -0.092412, 0.760300, 0.273200,
		0.262862, 0.433522, 0.160099, 0.201700, 0.223700,
		-0.024605, 0.432509, -0.190748, 0.321200, 0.321500,
		-0.023592, 0.433522, 0.195692, 0.189600, 0.321500,
		-0.074396, -0.515674, -0.190748, 0.705500, 0.727800,
		-0.074045, -0.466478, -0.240295, 0.684900, 0.715800,
		-0.057757, -0.499267, -0.223794, 0.698600, 0.715800,
		-0.123592, 0.333522, -0.190748, 0.411700, 0.739700,
		-0.057314, 0.366890, -0.223658, 0.397700, 0.715700,
		-0.073999, 0.333522, -0.240341, 0.411700, 0.715700,
		-0.123592, 0.333522, -0.190748, 0.411700, 0.739700,
		-0.074045, -0.466478, -0.240295, 0.684900, 0.715800,
		-0.123592, -0.466478, -0.190748, 0.684900, 0.739700,
		-0.123592, -0.466478, -0.190748, 0.000000, 0.418200,
		-0.074504, -0.515566, -0.141346, 0.023700, 0.435000,
		-0.123592, -0.466478, -0.092412, 0.000000, 0.451700,
		-0.123592, 0.333522, -0.190748, 0.321500, 0.369800,
		-0.023592, 0.433522, 0.195692, 0.189600, 0.321500,
		-0.024605, 0.432509, -0.190748, 0.321500, 0.322000,
		-0.123592, 0.333522, 0.220579, 0.896600, 0.306500,
		-0.123592, 0.045498, 0.256471, 0.896500, 0.896500,
		0.262862, 0.433522, 0.160099, 0.102800, 0.102800,
		0.262862, 0.433522, 0.160099, 1.000000, 0.102800,
		-0.123592, 0.045498, 0.256471, 1.000000, 0.896500,
		0.374395, -0.066562, 0.208138, 0.000000, 0.000000,
		-0.123592, 0.045498, 0.256471, 1.000000, 0.896500,
		-0.123592, -0.010775, 0.263445, 0.908100, 0.908100,
		0.374395, -0.066562, 0.208138, 0.000000, 0.000000,
		-0.057314, 0.366890, -0.223658, 0.788400, 0.000000,
		-0.024605, 0.432509, -0.190748, 0.909400, 0.205700,
		0.318537, 0.433522, 0.153143, 0.908700, 0.908700,
		-0.057757, -0.499267, -0.223794, 0.213100, 0.000000,
		0.369561, -0.072312, 0.204279, 1.000000, 0.000000,
		-0.074504, -0.515566, -0.141346, 1.000000, 0.817000,
		0.369561, -0.072312, 0.204279, 0.000000, 0.000000,
		-0.123592, -0.066434, 0.262994, 0.907900, 0.000000,
		-0.123592, -0.466478, -0.092412, 0.907500, 0.728700,
		-0.057314, 0.366890, -0.223658, 1.000000, 0.211600,
		0.374395, -0.066562, 0.208138, 1.000000, 1.000000,
		-0.073999, 0.333522, -0.240341, 0.954400, 0.181100,
		0.374395, -0.066562, 0.208138, 1.000000, 1.000000,
		-0.057757, -0.499267, -0.223794, 0.211200, 0.211200,
		-0.074045, -0.466478, -0.240295, 0.226000, 0.181500,
		-0.123592, -0.466478, -0.092412, 0.760300, 0.273200,
		-0.123592, -0.066434, 0.262994, 0.881900, 0.410100,
		-0.123592, 0.333522, -0.190748, 0.726800, 0.546500,
		-0.123592, -0.066434, 0.262994, 0.881900, 0.410100,
		-0.123592, -0.010775, 0.263445, 0.881900, 0.428900,
		-0.123592, 0.333522, -0.190748, 0.726800, 0.546500,
		-0.123592, -0.010775, 0.263445, 0.881900, 0.428900,
		-0.123592, 0.045498, 0.256471, 0.879500, 0.448100,
		-0.123592, 0.333522, -0.190748, 0.726800, 0.546500,
		-0.123592, 0.045498, 0.256471, 0.879500, 0.448100,
		-0.123592, 0.333522, 0.220579, 0.867200, 0.546500,
		-0.123592, 0.333522, -0.190748, 0.726800, 0.546500,
		0.262862, 0.433522, 0.160099, 0.201700, 0.223700,
		0.318537, 0.433522, 0.153143, 0.204100, 0.204700,
		-0.024605, 0.432509, -0.190748, 0.321200, 0.321500,
		-0.074396, -0.515674, -0.190748, 0.705500, 0.727800,
		-0.123592, -0.466478, -0.190748, 0.684900, 0.739700,
		-0.074045, -0.466478, -0.240295, 0.684900, 0.715800,
		-0.123592, 0.333522, -0.190748, 0.411700, 0.739700,
		-0.024605, 0.432509, -0.190748, 0.370300, 0.715800,
		-0.057314, 0.366890, -0.223658, 0.397700, 0.715700,
		-0.123592, 0.333522, -0.190748, 0.411700, 0.739700,
		-0.073999, 0.333522, -0.240341, 0.411700, 0.715700,
		-0.074045, -0.466478, -0.240295, 0.684900, 0.715800,
		-0.123592, -0.466478, -0.190748, 0.000000, 0.418200,
		-0.074396, -0.515674, -0.190748, 0.023800, 0.418200,
		-0.074504, -0.515566, -0.141346, 0.023700, 0.435000,
		-0.123592, 0.333522, -0.190748, 0.321500, 0.369800,
		-0.123592, 0.333522, 0.220579, 0.181100, 0.369800,
		-0.023592, 0.433522, 0.195692, 0.189600, 0.321500
	};
};

struct Block_05	//структура описания геометрии модели кусочка блока
{
	int vertices = 84;
	int faces = 28;
	
	
	float geometry[84*5] = {	// в данном массиве хранится описание геометрии пола: 36 вершин в формате position.xyz texCoord.uv
		0.054601, -0.384967, -0.237416, 1.000000, 0.000000,
		-0.000196, 0.110920, -0.292156, 1.000000, 0.907800,
		0.060672, 0.110920, -0.292061, 0.091100, 0.000000,
		0.054601, -0.384967, -0.237416, 1.000000, 1.000000,
		0.060672, 0.110920, -0.292061, 0.091100, 0.091100,
		0.455438, 0.110920, 0.151788, 0.820200, 0.090800,
		0.379306, 0.061430, 0.211874, 0.203600, 0.000000,
		-0.444562, -0.303926, -0.154169, 0.954800, 0.000000,
		0.054601, -0.384967, -0.237416, 1.000000, 1.000000,
		-0.344562, 0.061628, 0.211675, 0.796600, 0.660000,
		-0.444562, -0.303926, -0.154169, 0.045200, 0.000000,
		0.379306, 0.061430, 0.211874, 0.796400, 0.000000,
		-0.444562, -0.303926, -0.154169, 0.891900, 0.438900,
		-0.444562, 0.010920, -0.224205, 0.868000, 0.546500,
		-0.444562, -0.331224, -0.181704, 0.882500, 0.429600,
		0.060672, 0.110920, -0.292061, 0.203500, 0.183100,
		-0.000196, 0.110920, -0.292156, 0.203600, 0.203900,
		-0.344562, 0.110920, 0.162384, 0.048300, 0.321500,
		-0.344562, 0.061628, 0.211675, 0.390500, 0.036100,
		-0.344562, 0.110920, 0.162384, 0.369800, 0.024200,
		-0.444562, 0.010920, 0.160879, 0.411100, 0.000000,
		0.463926, 0.102432, 0.162384, 0.373400, 0.347700,
		0.455438, 0.061544, 0.211760, 0.390500, 0.333800,
		0.487311, 0.045724, 0.195706, 0.397100, 0.345300,
		-0.344562, 0.110920, 0.162384, 0.048300, 0.321500,
		-0.444562, 0.010920, -0.224205, 0.180300, 0.369800,
		-0.444562, 0.010920, 0.160879, 0.048300, 0.369100,
		-0.344562, 0.110920, 0.162384, 0.048300, 0.321500,
		-0.344562, 0.061628, 0.211675, 0.024500, 0.321500,
		0.379306, 0.061430, 0.211874, 0.024400, 0.074300,
		0.463926, 0.102432, 0.162384, 0.048300, 0.044200,
		0.455438, 0.110920, 0.151788, 0.051900, 0.048300,
		0.455438, 0.110920, 0.162384, 0.048300, 0.048300,
		-0.344562, 0.110920, -0.249123, 0.908500, 0.204500,
		0.054601, -0.384967, -0.237416, 1.000000, 1.000000,
		-0.444562, 0.010920, -0.224205, 0.794500, 0.091200,
		0.463926, 0.102432, 0.162384, 0.851600, 0.106400,
		0.487311, 0.045724, 0.195706, 1.000000, 0.210300,
		0.455438, 0.110920, 0.151788, 0.820200, 0.090800,
		0.487311, 0.045724, 0.195706, 1.000000, 0.210300,
		0.054601, -0.384967, -0.237416, 1.000000, 1.000000,
		0.455438, 0.110920, 0.151788, 0.820200, 0.090800,
		-0.444562, -0.331224, -0.181704, 1.000000, 0.090300,
		0.054601, -0.384967, -0.237416, 1.000000, 1.000000,
		-0.444562, -0.303926, -0.154169, 0.954800, 0.000000,
		0.054601, -0.384967, -0.237416, 1.000000, 1.000000,
		0.487311, 0.045724, 0.195706, 0.210300, 0.210300,
		0.379306, 0.061430, 0.211874, 0.203600, 0.000000,
		0.487311, 0.045724, 0.195706, 0.210300, 0.210300,
		0.455438, 0.061544, 0.211760, 0.189800, 0.111300,
		0.379306, 0.061430, 0.211874, 0.203600, 0.000000,
		-0.344562, 0.061628, 0.211675, 0.796600, 0.660000,
		-0.444562, 0.010920, 0.160879, 0.692400, 0.646900,
		-0.444562, -0.303926, -0.154169, 0.045200, 0.000000,
		-0.444562, -0.303926, -0.154169, 0.891900, 0.438900,
		-0.444562, 0.010920, 0.160879, 0.999500, 0.546500,
		-0.444562, 0.010920, -0.224205, 0.868000, 0.546500,
		-0.344562, 0.110920, -0.249123, 0.188900, 0.321500,
		-0.344562, 0.110920, 0.162384, 0.048300, 0.321500,
		-0.000196, 0.110920, -0.292156, 0.203600, 0.203900,
		-0.344562, 0.110920, 0.162384, 0.048300, 0.321500,
		0.455438, 0.110920, 0.162384, 0.048300, 0.048300,
		0.455438, 0.110920, 0.151788, 0.051900, 0.048300,
		0.060672, 0.110920, -0.292061, 0.203500, 0.183100,
		-0.344562, 0.110920, 0.162384, 0.048300, 0.321500,
		0.455438, 0.110920, 0.151788, 0.051900, 0.048300,
		0.463926, 0.102432, 0.162384, 0.373400, 0.347700,
		0.455438, 0.110920, 0.162384, 0.369800, 0.345700,
		0.455438, 0.061544, 0.211760, 0.390500, 0.333800,
		-0.344562, 0.110920, 0.162384, 0.048300, 0.321500,
		-0.344562, 0.110920, -0.249123, 0.188900, 0.321500,
		-0.444562, 0.010920, -0.224205, 0.180300, 0.369800,
		0.379306, 0.061430, 0.211874, 0.024400, 0.074300,
		0.455438, 0.061544, 0.211760, 0.024500, 0.048300,
		0.455438, 0.110920, 0.162384, 0.048300, 0.048300,
		0.455438, 0.110920, 0.162384, 0.048300, 0.048300,
		-0.344562, 0.110920, 0.162384, 0.048300, 0.321500,
		0.379306, 0.061430, 0.211874, 0.024400, 0.074300,
		-0.000196, 0.110920, -0.292156, 0.907800, 0.907800,
		0.054601, -0.384967, -0.237416, 1.000000, 1.000000,
		-0.344562, 0.110920, -0.249123, 0.908500, 0.204500,
		0.054601, -0.384967, -0.237416, 1.000000, 1.000000,
		-0.444562, -0.331224, -0.181704, 0.090300, 0.090300,
		-0.444562, 0.010920, -0.224205, 0.794500, 0.091200
	};
};

struct Block_06	//структура описания геометрии модели кусочка блока
{
	int vertices = 78;
	int faces = 26;
	
	float geometry[78*5] = {	// в данном массиве хранится описание геометрии пола: 36 вершин в формате position.xyz texCoord.uv
		-0.306127, -0.290262, 0.139286, 0.000000, 0.000000,
		0.092547, -0.334270, -0.360272, 0.909500, 0.703600,
		0.192547, -0.345419, 0.083416, 0.090800, 0.000000,
		0.192547, 0.108844, 0.537770, 0.906000, 0.747700,
		-0.306127, -0.290262, 0.139286, 0.000000, 0.000000,
		0.192547, -0.345419, 0.083416, 0.909200, 0.000000,
		0.092547, 0.208844, 0.525801, 0.816300, 0.724900,
		-0.299800, 0.208844, 0.084225, 0.091800, 0.000000,
		-0.306127, -0.290262, 0.139286, 1.000000, 0.000000,
		0.192547, 0.108844, -0.260272, 1.000000, 0.000000,
		0.192547, -0.345419, 0.083416, 0.844800, 0.117400,
		0.192547, -0.345403, -0.260272, 0.844800, 0.000000,
		0.092547, 0.208844, -0.260272, 0.321500, 0.048300,
		-0.299800, 0.208844, 0.084225, 0.203900, 0.182300,
		0.092547, 0.208844, 0.525801, 0.053100, 0.048300,
		0.092547, 0.108844, -0.360272, 0.411700, 0.418200,
		0.092547, 0.208844, -0.260272, 0.369800, 0.394000,
		0.192547, 0.108844, -0.260272, 0.411700, 0.369800,
		0.126252, 0.142920, 0.571947, 0.397400, 0.346100,
		0.192547, 0.108844, 0.537770, 0.410900, 0.369400,
		0.103689, 0.197702, 0.539728, 0.374500, 0.348400,
		0.092547, 0.208844, -0.260272, 0.321500, 0.048300,
		-0.251130, 0.108844, -0.360272, 0.369800, 0.165700,
		-0.262067, 0.208844, -0.260272, 0.321500, 0.169400,
		0.192547, 0.108844, -0.260272, 0.321500, 0.000000,
		0.092547, 0.208844, -0.260272, 0.321500, 0.048300,
		0.092547, 0.208844, 0.525801, 0.053100, 0.048300,
		0.092547, -0.334270, -0.360272, 0.563000, 0.418200,
		0.192547, 0.108844, -0.260272, 0.411700, 0.369800,
		0.192547, -0.345403, -0.260272, 0.566800, 0.369800,
		0.092547, 0.108844, -0.360272, 0.411700, 0.418200,
		-0.251195, -0.296017, -0.360272, 0.550000, 0.535600,
		-0.251130, 0.108844, -0.360272, 0.411700, 0.535500,
		-0.251130, 0.108844, -0.360272, 0.909400, 0.180100,
		-0.306127, -0.290262, 0.139286, 1.000000, 1.000000,
		-0.262067, 0.208844, -0.260272, 0.795700, 0.090900,
		-0.251195, -0.296017, -0.360272, 0.909600, 0.000000,
		0.092547, -0.334270, -0.360272, 0.909500, 0.703600,
		-0.306127, -0.290262, 0.139286, 0.000000, 0.000000,
		0.092547, -0.334270, -0.360272, 0.909500, 0.703600,
		0.192547, -0.345403, -0.260272, 0.795900, 0.704600,
		0.192547, -0.345419, 0.083416, 0.090800, 0.000000,
		0.192547, 0.108844, 0.537770, 0.906000, 0.747700,
		0.126252, 0.142920, 0.571947, 0.788700, 0.788700,
		-0.306127, -0.290262, 0.139286, 0.000000, 0.000000,
		-0.306127, -0.290262, 0.139286, 1.000000, 0.000000,
		0.126252, 0.142920, 0.571947, 1.000000, 0.788700,
		0.092547, 0.208844, 0.525801, 0.816300, 0.724900,
		0.126252, 0.142920, 0.571947, 1.000000, 0.788700,
		0.103689, 0.197702, 0.539728, 0.857400, 0.745800,
		0.092547, 0.208844, 0.525801, 0.816300, 0.724900,
		0.192547, 0.108844, -0.260272, 1.000000, 0.000000,
		0.192547, 0.108844, 0.537770, 1.000000, 0.272600,
		0.192547, -0.345419, 0.083416, 0.844800, 0.117400,
		0.092547, 0.208844, -0.260272, 0.321500, 0.048300,
		-0.262067, 0.208844, -0.260272, 0.321500, 0.169400,
		-0.299800, 0.208844, 0.084225, 0.203900, 0.182300,
		0.092547, 0.208844, -0.260272, 0.321500, 0.048300,
		0.092547, 0.108844, -0.360272, 0.369800, 0.048300,
		-0.251130, 0.108844, -0.360272, 0.369800, 0.165700,
		0.103689, 0.197702, 0.539728, 0.048300, 0.042900,
		0.192547, 0.108844, 0.537770, 0.049000, 0.000000,
		0.092547, 0.208844, 0.525801, 0.053100, 0.048300,
		0.192547, 0.108844, 0.537770, 0.049000, 0.000000,
		0.192547, 0.108844, -0.260272, 0.321500, 0.000000,
		0.092547, 0.208844, 0.525801, 0.053100, 0.048300,
		0.092547, -0.334270, -0.360272, 0.563000, 0.418200,
		0.092547, 0.108844, -0.360272, 0.411700, 0.418200,
		0.192547, 0.108844, -0.260272, 0.411700, 0.369800,
		0.092547, 0.108844, -0.360272, 0.411700, 0.418200,
		0.092547, -0.334270, -0.360272, 0.563000, 0.418200,
		-0.251195, -0.296017, -0.360272, 0.550000, 0.535600,
		-0.251195, -0.296017, -0.360272, 0.909600, 0.909600,
		-0.306127, -0.290262, 0.139286, 1.000000, 1.000000,
		-0.251130, 0.108844, -0.360272, 0.909400, 0.180100,
		-0.306127, -0.290262, 0.139286, 1.000000, 1.000000,
		-0.299800, 0.208844, 0.084225, 0.091800, 0.091800,
		-0.262067, 0.208844, -0.260272, 0.795700, 0.090900
	};
};

struct Block_07	//структура описания геометрии модели кусочка блока
{
	int vertices = 84;
	int faces = 28;
	
	float geometry[84*5] = {	// в данном массиве хранится описание геометрии пола: 36 вершин в формате position.xyz texCoord.uv
		0.277399, 0.256139, -0.228679, 0.000000, 0.000000,
		0.333112, 0.256000, 0.271222, 0.908300, 0.000000,
		0.333280, 0.201326, 0.271222, 0.909100, 0.909100,
		0.277399, 0.256139, -0.228679, 0.000000, 0.000000,
		-0.121310, 0.256227, 0.271222, 0.908800, 0.164000,
		0.333112, 0.256000, 0.271222, 0.908300, 0.908300,
		-0.121310, -0.243077, -0.527565, 0.299400, 0.208200,
		0.277399, 0.256139, -0.228679, 1.000000, 0.000000,
		0.214733, -0.243077, -0.228327, 1.000000, 0.909600,
		0.277399, 0.256139, -0.228679, 1.000000, 1.000000,
		-0.221310, -0.143077, -0.527360, 0.273600, 0.091000,
		-0.221310, 0.255692, -0.172548, 1.000000, 0.090800,
		-0.171436, 0.256263, 0.221096, 1.000000, 0.182300,
		-0.221310, 0.255692, -0.172548, 0.090800, 0.090800,
		-0.221310, 0.256145, 0.171222, 0.795400, 0.091300,
		-0.121310, -0.243077, 0.171222, 0.048300, 0.691400,
		0.214733, -0.243077, -0.228327, 0.163100, 0.554900,
		0.264742, -0.243077, 0.171222, 0.180200, 0.691400,
		0.333280, 0.201326, 0.271222, 0.567300, 0.203600,
		-0.121310, 0.256227, 0.271222, 0.548500, 0.048300,
		0.289865, -0.143077, 0.271222, 0.684900, 0.188700,
		-0.221310, -0.143077, 0.171222, 1.000000, 0.273200,
		-0.221310, 0.255692, -0.172548, 0.882600, 0.409400,
		-0.221310, -0.143077, -0.527360, 0.761400, 0.273200,
		-0.121310, -0.243077, 0.171222, 0.726800, 0.024200,
		-0.121310, -0.143077, 0.271222, 0.684900, 0.048300,
		-0.221310, -0.143077, 0.171222, 0.684900, 0.000000,
		-0.121310, -0.243077, 0.171222, 0.048300, 0.691400,
		-0.221310, -0.143077, 0.171222, 0.000000, 0.691400,
		-0.221310, -0.143077, -0.527360, 0.000000, 0.452800,
		-0.121310, -0.143077, 0.271222, 0.684900, 0.048300,
		-0.121310, 0.256227, 0.271222, 0.548500, 0.048300,
		-0.171436, 0.256263, 0.221096, 0.548500, 0.024100,
		-0.121310, -0.143077, 0.271222, 0.048300, 0.739700,
		0.264742, -0.243077, 0.171222, 0.180200, 0.691400,
		0.289865, -0.143077, 0.271222, 0.188700, 0.739700,
		0.277399, 0.256139, -0.228679, 1.000000, 0.000000,
		0.333280, 0.201326, 0.271222, 1.000000, 0.909100,
		0.289865, -0.143077, 0.271222, 0.398200, 0.306800,
		0.277399, 0.256139, -0.228679, 0.000000, 0.000000,
		-0.171436, 0.256263, 0.221096, 0.817700, 0.000000,
		-0.121310, 0.256227, 0.271222, 0.908800, 0.164000,
		-0.121310, -0.243077, -0.527565, 0.299400, 0.208200,
		-0.171212, -0.193175, -0.577614, 0.182300, 0.000000,
		0.277399, 0.256139, -0.228679, 1.000000, 0.000000,
		0.277399, 0.256139, -0.228679, 1.000000, 1.000000,
		-0.171212, -0.193175, -0.577614, 0.182300, 0.182300,
		-0.221310, -0.143077, -0.527360, 0.273600, 0.091000,
		-0.171436, 0.256263, 0.221096, 1.000000, 0.182300,
		0.277399, 0.256139, -0.228679, 1.000000, 1.000000,
		-0.221310, 0.255692, -0.172548, 0.090800, 0.090800,
		-0.121310, -0.243077, 0.171222, 0.048300, 0.691400,
		-0.121310, -0.243077, -0.527565, 0.048300, 0.452700,
		0.214733, -0.243077, -0.228327, 0.163100, 0.554900,
		0.333112, 0.256000, 0.271222, 0.548600, 0.203500,
		-0.121310, 0.256227, 0.271222, 0.548500, 0.048300,
		0.333280, 0.201326, 0.271222, 0.567300, 0.203600,
		-0.121310, 0.256227, 0.271222, 0.548500, 0.048300,
		-0.121310, -0.143077, 0.271222, 0.684900, 0.048300,
		0.289865, -0.143077, 0.271222, 0.684900, 0.188700,
		-0.221310, -0.143077, 0.171222, 1.000000, 0.273200,
		-0.221310, 0.256145, 0.171222, 1.000000, 0.409600,
		-0.221310, 0.255692, -0.172548, 0.882600, 0.409400,
		-0.221310, -0.143077, -0.527360, 0.000000, 0.452800,
		-0.171212, -0.193175, -0.577614, 0.024200, 0.435600,
		-0.121310, -0.243077, -0.527565, 0.048300, 0.452700,
		-0.121310, -0.243077, -0.527565, 0.048300, 0.452700,
		-0.121310, -0.243077, 0.171222, 0.048300, 0.691400,
		-0.221310, -0.143077, -0.527360, 0.000000, 0.452800,
		-0.171436, 0.256263, 0.221096, 0.548500, 0.024100,
		-0.221310, 0.256145, 0.171222, 0.548600, 0.000000,
		-0.221310, -0.143077, 0.171222, 0.684900, 0.000000,
		-0.221310, -0.143077, 0.171222, 0.684900, 0.000000,
		-0.121310, -0.143077, 0.271222, 0.684900, 0.048300,
		-0.171436, 0.256263, 0.221096, 0.548500, 0.024100,
		-0.121310, -0.143077, 0.271222, 0.048300, 0.739700,
		-0.121310, -0.243077, 0.171222, 0.048300, 0.691400,
		0.264742, -0.243077, 0.171222, 0.180200, 0.691400,
		0.289865, -0.143077, 0.271222, 0.398200, 0.306800,
		0.264742, -0.243077, 0.171222, 0.375500, 0.102200,
		0.277399, 0.256139, -0.228679, 1.000000, 0.000000,
		0.264742, -0.243077, 0.171222, 0.375500, 0.102200,
		0.214733, -0.243077, -0.228327, 0.090400, 0.000000,
		0.277399, 0.256139, -0.228679, 1.000000, 0.000000
	};
};

struct Block_08	//структура описания геометрии модели кусочка блока
{
	int vertices = 66;
	int faces = 22;
	
	
	float geometry[66*5] = {	// в данном массиве хранится описание геометрии пола: 36 вершин в формате position.xyz texCoord.uv
		-0.202906, -0.083082, 0.160379, 0.182000, 0.182000,
		-0.147561, 0.309353, 0.210267, 1.000000, 0.091400,
		-0.203603, 0.364855, -0.289185, 1.000000, 1.000000,
		-0.203603, 0.364855, -0.289185, 1.000000, 1.000000,
		-0.097418, 0.259250, 0.210267, 0.091500, 0.000000,
		0.245387, -0.083675, -0.176721, 0.796100, 0.000000,
		-0.203603, 0.364855, -0.289185, 1.000000, 1.000000,
		0.195868, -0.133193, -0.288741, 0.251400, 0.090900,
		-0.265104, -0.133193, -0.288837, 1.000000, 0.092000,
		-0.215346, -0.133193, 0.110267, 0.817500, 0.090800,
		-0.203603, 0.364855, -0.289185, 1.000000, 1.000000,
		-0.265104, -0.133193, -0.288837, 0.092000, 0.092000,
		0.245252, -0.083810, 0.110267, 0.477200, 0.204100,
		-0.097418, 0.259250, 0.210267, 1.000000, 0.908500,
		0.194613, -0.033193, 0.210267, 0.398800, 0.305600,
		0.195868, -0.133193, -0.288741, 0.321500, 0.555100,
		-0.215346, -0.133193, 0.110267, 0.181100, 0.691400,
		-0.265104, -0.133193, -0.288837, 0.164100, 0.555100,
		-0.190379, -0.033193, 0.210267, 0.684900, 0.189600,
		-0.097418, 0.259250, 0.210267, 0.585000, 0.221400,
		-0.147561, 0.309353, 0.210267, 0.567900, 0.204200,
		0.194613, -0.033193, 0.210267, 0.685500, 0.321900,
		0.195868, -0.133193, 0.110267, 0.726800, 0.345700,
		0.245252, -0.083810, 0.110267, 0.706100, 0.357600,
		0.245387, -0.083675, -0.176721, 0.345500, 0.593400,
		0.195868, -0.133193, 0.110267, 0.321500, 0.691400,
		0.195868, -0.133193, -0.288741, 0.321500, 0.555100,
		-0.202906, -0.083082, 0.160379, 0.185300, 0.715600,
		-0.215346, -0.133193, 0.110267, 0.181100, 0.691400,
		0.195868, -0.133193, 0.110267, 0.321500, 0.691400,
		-0.202906, -0.083082, 0.160379, 0.182000, 0.182000,
		-0.190379, -0.033193, 0.210267, 0.296000, 0.091300,
		-0.147561, 0.309353, 0.210267, 1.000000, 0.091400,
		0.245387, -0.083675, -0.176721, 0.796100, 0.000000,
		0.245331, -0.083731, -0.288767, 1.000000, 0.181000,
		-0.203603, 0.364855, -0.289185, 1.000000, 1.000000,
		-0.203603, 0.364855, -0.289185, 1.000000, 1.000000,
		-0.147561, 0.309353, 0.210267, 0.091400, 0.091400,
		-0.097418, 0.259250, 0.210267, 0.091500, 0.000000,
		-0.203603, 0.364855, -0.289185, 1.000000, 1.000000,
		0.245331, -0.083731, -0.288767, 0.181000, 0.181000,
		0.195868, -0.133193, -0.288741, 0.251400, 0.090900,
		-0.215346, -0.133193, 0.110267, 0.817500, 0.090800,
		-0.202906, -0.083082, 0.160379, 1.000000, 0.182000,
		-0.203603, 0.364855, -0.289185, 1.000000, 1.000000,
		0.245252, -0.083810, 0.110267, 0.477200, 0.204100,
		0.245387, -0.083675, -0.176721, 1.000000, 0.203900,
		-0.097418, 0.259250, 0.210267, 1.000000, 0.908500,
		0.195868, -0.133193, -0.288741, 0.321500, 0.555100,
		0.195868, -0.133193, 0.110267, 0.321500, 0.691400,
		-0.215346, -0.133193, 0.110267, 0.181100, 0.691400,
		-0.190379, -0.033193, 0.210267, 0.684900, 0.189600,
		0.194613, -0.033193, 0.210267, 0.684900, 0.321100,
		-0.097418, 0.259250, 0.210267, 0.585000, 0.221400,
		0.195868, -0.133193, -0.288741, 0.321500, 0.555100,
		0.245331, -0.083731, -0.288767, 0.345400, 0.555100,
		0.245387, -0.083675, -0.176721, 0.345500, 0.593400,
		0.245387, -0.083675, -0.176721, 0.345500, 0.593400,
		0.245252, -0.083810, 0.110267, 0.345400, 0.691400,
		0.195868, -0.133193, 0.110267, 0.321500, 0.691400,
		0.195868, -0.133193, 0.110267, 0.321500, 0.691400,
		0.194613, -0.033193, 0.210267, 0.321100, 0.739700,
		-0.202906, -0.083082, 0.160379, 0.185300, 0.715600,
		0.194613, -0.033193, 0.210267, 0.321100, 0.739700,
		-0.190379, -0.033193, 0.210267, 0.189600, 0.739700,
		-0.202906, -0.083082, 0.160379, 0.185300, 0.715600
	};
};

struct Block_09	//структура описания геометрии модели кусочка блока
{
	int vertices = 78;
	int faces = 26;
	
	
	float geometry[78*5] = {	// в данном массиве хранится описание геометрии пола: 36 вершин в формате position.xyz texCoord.uv
		-0.337569, 0.068045, -0.293028, 1.000000, 0.000000,
		-0.283073, 0.013471, 0.200031, 1.000000, 0.907400,
		-0.282877, 0.068354, 0.200031, 0.092100, 0.000000,
		-0.337569, 0.068045, -0.293028, 0.000000, 0.000000,
		-0.337538, 0.067446, -0.299151, 1.000000, 0.000000,
		-0.283073, 0.013471, 0.200031, 0.907400, 0.907400,
		-0.283073, 0.013471, 0.200031, 0.908400, 0.908400,
		0.093829, -0.364528, 0.133534, 0.788200, 0.000000,
		0.060192, -0.330728, 0.200031, 0.909100, 0.204900,
		-0.337538, 0.067446, -0.299151, 0.000000, 0.000000,
		0.110602, -0.381258, 0.100031, 0.818900, 0.727200,
		0.093829, -0.364528, 0.133534, 0.788200, 0.788200,
		0.158638, 0.468332, 0.101585, 0.836600, 0.745200,
		-0.337538, 0.067446, -0.299151, 1.000000, 0.000000,
		0.094456, 0.500414, 0.133686, 1.000000, 0.788400,
		-0.337569, 0.068045, -0.293028, 1.000000, 0.000000,
		0.094456, 0.500414, 0.133686, 0.788400, 0.788400,
		-0.337538, 0.067446, -0.299151, 0.000000, 0.000000,
		-0.337569, 0.068045, -0.293028, 0.000000, 0.000000,
		-0.282877, 0.068354, 0.200031, 0.907900, 0.000000,
		0.060192, 0.453966, 0.200031, 0.908200, 0.703400,
		0.110869, -0.380991, -0.299411, 1.000000, 0.180700,
		0.160192, 0.012479, -0.354265, 0.090900, 0.090900,
		0.160192, -0.331668, -0.311654, 0.797500, 0.090600,
		0.160192, 0.012479, -0.354265, 0.844300, 0.118100,
		0.160192, -0.331668, 0.100031, 0.726800, 0.273200,
		0.160192, -0.331668, -0.311654, 0.726800, 0.132600,
		0.060192, -0.330728, 0.200031, 0.684600, 0.321500,
		-0.282877, 0.068354, 0.200031, 0.548300, 0.204400,
		-0.283073, 0.013471, 0.200031, 0.567100, 0.204300,
		0.093829, -0.364528, 0.133534, 0.698700, 0.345700,
		0.160192, -0.331668, 0.100031, 0.684900, 0.369800,
		0.060192, -0.330728, 0.200031, 0.684900, 0.322000,
		0.158638, 0.468332, 0.101585, 0.411700, 0.369100,
		0.094456, 0.500414, 0.133686, 0.398400, 0.345500,
		0.071703, 0.468332, 0.188520, 0.411700, 0.327100,
		0.158638, 0.468332, 0.101585, 0.411700, 0.369100,
		0.071703, 0.468332, 0.188520, 0.411700, 0.327100,
		0.060192, 0.453966, 0.200031, 0.416600, 0.321500,
		0.160192, -0.331668, 0.100031, 0.369800, 0.691400,
		0.110869, -0.380991, -0.299411, 0.346000, 0.555000,
		0.160192, -0.331668, -0.311654, 0.369800, 0.550800,
		-0.283073, 0.013471, 0.200031, 0.908400, 0.908400,
		-0.337538, 0.067446, -0.299151, 0.000000, 0.000000,
		0.093829, -0.364528, 0.133534, 0.788200, 0.000000,
		-0.337538, 0.067446, -0.299151, 0.000000, 0.000000,
		0.110869, -0.380991, -0.299411, 0.819300, 0.000000,
		0.110602, -0.381258, 0.100031, 0.818900, 0.727200,
		0.158638, 0.468332, 0.101585, 0.836600, 0.745200,
		0.160192, 0.012479, -0.354265, 0.090900, 0.000000,
		-0.337538, 0.067446, -0.299151, 1.000000, 0.000000,
		0.060192, 0.453966, 0.200031, 0.908200, 0.703400,
		0.071703, 0.468332, 0.188520, 0.887000, 0.729600,
		0.094456, 0.500414, 0.133686, 0.787600, 0.787600,
		0.094456, 0.500414, 0.133686, 0.787600, 0.787600,
		-0.337569, 0.068045, -0.293028, 0.000000, 0.000000,
		0.060192, 0.453966, 0.200031, 0.908200, 0.703400,
		0.110869, -0.380991, -0.299411, 1.000000, 0.180700,
		-0.337538, 0.067446, -0.299151, 1.000000, 1.000000,
		0.160192, 0.012479, -0.354265, 0.090900, 0.090900,
		0.160192, 0.012479, -0.354265, 0.844300, 0.118100,
		0.158638, 0.468332, 0.101585, 0.999500, 0.273200,
		0.160192, -0.331668, 0.100031, 0.726800, 0.273200,
		0.060192, -0.330728, 0.200031, 0.684600, 0.321500,
		0.060192, 0.453966, 0.200031, 0.416600, 0.321500,
		-0.282877, 0.068354, 0.200031, 0.548300, 0.204400,
		0.093829, -0.364528, 0.133534, 0.698700, 0.345700,
		0.110602, -0.381258, 0.100031, 0.705700, 0.357900,
		0.160192, -0.331668, 0.100031, 0.684900, 0.369800,
		0.060192, 0.453966, 0.200031, 0.416600, 0.321500,
		0.060192, -0.330728, 0.200031, 0.684900, 0.322000,
		0.160192, -0.331668, 0.100031, 0.684900, 0.369800,
		0.160192, -0.331668, 0.100031, 0.684900, 0.369800,
		0.158638, 0.468332, 0.101585, 0.411700, 0.369100,
		0.060192, 0.453966, 0.200031, 0.416600, 0.321500,
		0.160192, -0.331668, 0.100031, 0.369800, 0.691400,
		0.110602, -0.381258, 0.100031, 0.345900, 0.691400,
		0.110869, -0.380991, -0.299411, 0.346000, 0.555000
	};
};



struct Ball_01	//структура описания геометрии модели мяча
{
	int vertices = 240;
	int faces = 80;
	
	
	float geometry[240*5] = {	// в данном массиве хранится описание геометрии пола: 36 вершин в формате position.xyz texCoord.uv
		
0.000000, 0.000000, -0.500000, 0.181800, 0.000000,
0.223605, -0.154506, -0.425327, 0.227300, 0.078700,
-0.085408, -0.249998, -0.425327, 0.136400, 0.078700,
0.380422, -0.262863, -0.223610, 0.272700, 0.157500,
0.223605, -0.154506, -0.425327, 0.318200, 0.078700,
0.447211, 0.000000, -0.262868, 0.363600, 0.157500,
0.000000, 0.000000, -0.500000, 0.909100, 0.000000,
-0.085408, -0.249998, -0.425327, 0.954500, 0.078700,
-0.276392, 0.000000, -0.425326, 0.863600, 0.078700,
0.000000, 0.000000, -0.500000, 0.727300, 0.000000,
-0.276392, 0.000000, -0.425326, 0.772700, 0.078700,
-0.085408, 0.249998, -0.425327, 0.681800, 0.078700,
0.000000, 0.000000, -0.500000, 0.545500, 0.000000,
-0.085408, 0.249998, -0.425327, 0.590900, 0.078700,
0.223605, 0.154506, -0.425327, 0.500000, 0.078700,
0.380422, -0.262863, -0.223610, 0.272700, 0.157500,
0.447211, 0.000000, -0.262868, 0.363600, 0.157500,
0.500000, -0.154506, 0.000000, 0.318200, 0.236200,
-0.145306, -0.425325, -0.223610, 0.090900, 0.157500,
0.138198, -0.404506, -0.262869, 0.181800, 0.157500,
0.000000, -0.500000, 0.000000, 0.136400, 0.236200,
-0.470227, 0.000000, -0.223608, 0.818200, 0.157500,
-0.361802, -0.249998, -0.262868, 0.909100, 0.157500,
-0.500000, -0.154506, 0.000000, 0.863600, 0.236200,
-0.145306, 0.425325, -0.223610, 0.636400, 0.157500,
-0.361802, 0.249998, -0.262868, 0.727300, 0.157500,
-0.309017, 0.404508, 0.000000, 0.681800, 0.236200,
0.380422, 0.262863, -0.223610, 0.454500, 0.157500,
0.138198, 0.404506, -0.262869, 0.545500, 0.157500,
0.309017, 0.404508, 0.000000, 0.500000, 0.236200,
0.380422, -0.262863, -0.223610, 0.272700, 0.157500,
0.500000, -0.154506, 0.000000, 0.318200, 0.236200,
0.309017, -0.404508, 0.000000, 0.227300, 0.236200,
-0.145306, -0.425325, -0.223610, 0.090900, 0.157500,
0.000000, -0.500000, 0.000000, 0.136400, 0.236200,
-0.309017, -0.404508, 0.000000, 0.045500, 0.236200,
-0.470227, 0.000000, -0.223608, 0.818200, 0.157500,
-0.500000, -0.154506, 0.000000, 0.863600, 0.236200,
-0.500000, 0.154506, 0.000000, 0.772700, 0.236200,
-0.145306, 0.425325, -0.223610, 0.636400, 0.157500,
-0.309017, 0.404508, 0.000000, 0.681800, 0.236200,
0.000000, 0.500000, 0.000000, 0.590900, 0.236200,
0.380422, 0.262863, -0.223610, 0.454500, 0.157500,
0.309017, 0.404508, 0.000000, 0.500000, 0.236200,
0.500000, 0.154506, 0.000000, 0.409100, 0.236200,
0.145306, -0.425325, 0.223610, 0.181800, 0.314900,
0.361802, -0.249998, 0.262868, 0.272700, 0.314900,
0.085408, -0.249998, 0.425327, 0.227300, 0.393700,
-0.380422, -0.262863, 0.223610, 0.000000, 0.314900,
-0.138198, -0.404506, 0.262869, 0.090900, 0.314900,
-0.223605, -0.154506, 0.425327, 0.045500, 0.393700,
-0.380422, 0.262863, 0.223610, 0.727300, 0.314900,
-0.447211, 0.000000, 0.262868, 0.818200, 0.314900,
-0.223605, 0.154506, 0.425327, 0.772700, 0.393700,
0.145306, 0.425325, 0.223610, 0.545500, 0.314900,
-0.138198, 0.404506, 0.262869, 0.636400, 0.314900,
0.085408, 0.249998, 0.425327, 0.590900, 0.393700,
0.470227, 0.000000, 0.223608, 0.363600, 0.314900,
0.361802, 0.249998, 0.262868, 0.454500, 0.314900,
0.276392, 0.000000, 0.425326, 0.409100, 0.393700,
0.276392, 0.000000, 0.425326, 0.409100, 0.393700,
0.085408, 0.249998, 0.425327, 0.500000, 0.393700,
0.000000, 0.000000, 0.500000, 0.454500, 0.472400,
0.276392, 0.000000, 0.425326, 0.409100, 0.393700,
0.361802, 0.249998, 0.262868, 0.454500, 0.314900,
0.085408, 0.249998, 0.425327, 0.500000, 0.393700,
0.361802, 0.249998, 0.262868, 0.454500, 0.314900,
0.145306, 0.425325, 0.223610, 0.545500, 0.314900,
0.085408, 0.249998, 0.425327, 0.500000, 0.393700,
0.085408, 0.249998, 0.425327, 0.590900, 0.393700,
-0.223605, 0.154506, 0.425327, 0.681800, 0.393700,
0.000000, 0.000000, 0.500000, 0.636400, 0.472400,
0.085408, 0.249998, 0.425327, 0.590900, 0.393700,
-0.138198, 0.404506, 0.262869, 0.636400, 0.314900,
-0.223605, 0.154506, 0.425327, 0.681800, 0.393700,
-0.138198, 0.404506, 0.262869, 0.636400, 0.314900,
-0.380422, 0.262863, 0.223610, 0.727300, 0.314900,
-0.223605, 0.154506, 0.425327, 0.681800, 0.393700,
-0.223605, 0.154506, 0.425327, 0.772700, 0.393700,
-0.223605, -0.154506, 0.425327, 0.863600, 0.393700,
0.000000, 0.000000, 0.500000, 0.818200, 0.472400,
-0.223605, 0.154506, 0.425327, 0.772700, 0.393700,
-0.447211, 0.000000, 0.262868, 0.818200, 0.314900,
-0.223605, -0.154506, 0.425327, 0.863600, 0.393700,
-0.447211, 0.000000, 0.262868, 0.818200, 0.314900,
-0.380422, -0.262863, 0.223610, 0.909100, 0.314900,
-0.223605, -0.154506, 0.425327, 0.863600, 0.393700,
-0.223605, -0.154506, 0.425327, 0.045500, 0.393700,
0.085408, -0.249998, 0.425327, 0.136400, 0.393700,
0.000000, 0.000000, 0.500000, 0.090900, 0.472400,
-0.223605, -0.154506, 0.425327, 0.045500, 0.393700,
-0.138198, -0.404506, 0.262869, 0.090900, 0.314900,
0.085408, -0.249998, 0.425327, 0.136400, 0.393700,
-0.138198, -0.404506, 0.262869, 0.090900, 0.314900,
0.145306, -0.425325, 0.223610, 0.181800, 0.314900,
0.085408, -0.249998, 0.425327, 0.136400, 0.393700,
0.085408, -0.249998, 0.425327, 0.227300, 0.393700,
0.276392, 0.000000, 0.425326, 0.318200, 0.393700,
0.000000, 0.000000, 0.500000, 0.272700, 0.472400,
0.085408, -0.249998, 0.425327, 0.227300, 0.393700,
0.361802, -0.249998, 0.262868, 0.272700, 0.314900,
0.276392, 0.000000, 0.425326, 0.318200, 0.393700,
0.361802, -0.249998, 0.262868, 0.272700, 0.314900,
0.470227, 0.000000, 0.223608, 0.363600, 0.314900,
0.276392, 0.000000, 0.425326, 0.318200, 0.393700,
0.500000, 0.154506, 0.000000, 0.409100, 0.236200,
0.361802, 0.249998, 0.262868, 0.454500, 0.314900,
0.470227, 0.000000, 0.223608, 0.363600, 0.314900,
0.500000, 0.154506, 0.000000, 0.409100, 0.236200,
0.309017, 0.404508, 0.000000, 0.500000, 0.236200,
0.361802, 0.249998, 0.262868, 0.454500, 0.314900,
0.309017, 0.404508, 0.000000, 0.500000, 0.236200,
0.145306, 0.425325, 0.223610, 0.545500, 0.314900,
0.361802, 0.249998, 0.262868, 0.454500, 0.314900,
0.000000, 0.500000, 0.000000, 0.590900, 0.236200,
-0.138198, 0.404506, 0.262869, 0.636400, 0.314900,
0.145306, 0.425325, 0.223610, 0.545500, 0.314900,
0.000000, 0.500000, 0.000000, 0.590900, 0.236200,
-0.309017, 0.404508, 0.000000, 0.681800, 0.236200,
-0.138198, 0.404506, 0.262869, 0.636400, 0.314900,
-0.309017, 0.404508, 0.000000, 0.681800, 0.236200,
-0.380422, 0.262863, 0.223610, 0.727300, 0.314900,
-0.138198, 0.404506, 0.262869, 0.636400, 0.314900,
-0.500000, 0.154506, 0.000000, 0.772700, 0.236200,
-0.447211, 0.000000, 0.262868, 0.818200, 0.314900,
-0.380422, 0.262863, 0.223610, 0.727300, 0.314900,
-0.500000, 0.154506, 0.000000, 0.772700, 0.236200,
-0.500000, -0.154506, 0.000000, 0.863600, 0.236200,
-0.447211, 0.000000, 0.262868, 0.818200, 0.314900,
-0.500000, -0.154506, 0.000000, 0.863600, 0.236200,
-0.380422, -0.262863, 0.223610, 0.909100, 0.314900,
-0.447211, 0.000000, 0.262868, 0.818200, 0.314900,
-0.309017, -0.404508, 0.000000, 0.045500, 0.236200,
-0.138198, -0.404506, 0.262869, 0.090900, 0.314900,
-0.380422, -0.262863, 0.223610, 0.000000, 0.314900,
-0.309017, -0.404508, 0.000000, 0.045500, 0.236200,
0.000000, -0.500000, 0.000000, 0.136400, 0.236200,
-0.138198, -0.404506, 0.262869, 0.090900, 0.314900,
0.000000, -0.500000, 0.000000, 0.136400, 0.236200,
0.145306, -0.425325, 0.223610, 0.181800, 0.314900,
-0.138198, -0.404506, 0.262869, 0.090900, 0.314900,
0.309017, -0.404508, 0.000000, 0.227300, 0.236200,
0.361802, -0.249998, 0.262868, 0.272700, 0.314900,
0.145306, -0.425325, 0.223610, 0.181800, 0.314900,
0.309017, -0.404508, 0.000000, 0.227300, 0.236200,
0.500000, -0.154506, 0.000000, 0.318200, 0.236200,
0.361802, -0.249998, 0.262868, 0.272700, 0.314900,
0.500000, -0.154506, 0.000000, 0.318200, 0.236200,
0.470227, 0.000000, 0.223608, 0.363600, 0.314900,
0.361802, -0.249998, 0.262868, 0.272700, 0.314900,
0.309017, 0.404508, 0.000000, 0.500000, 0.236200,
0.000000, 0.500000, 0.000000, 0.590900, 0.236200,
0.145306, 0.425325, 0.223610, 0.545500, 0.314900,
0.309017, 0.404508, 0.000000, 0.500000, 0.236200,
0.138198, 0.404506, -0.262869, 0.545500, 0.157500,
0.000000, 0.500000, 0.000000, 0.590900, 0.236200,
0.138198, 0.404506, -0.262869, 0.545500, 0.157500,
-0.145306, 0.425325, -0.223610, 0.636400, 0.157500,
0.000000, 0.500000, 0.000000, 0.590900, 0.236200,
-0.309017, 0.404508, 0.000000, 0.681800, 0.236200,
-0.500000, 0.154506, 0.000000, 0.772700, 0.236200,
-0.380422, 0.262863, 0.223610, 0.727300, 0.314900,
-0.309017, 0.404508, 0.000000, 0.681800, 0.236200,
-0.361802, 0.249998, -0.262868, 0.727300, 0.157500,
-0.500000, 0.154506, 0.000000, 0.772700, 0.236200,
-0.361802, 0.249998, -0.262868, 0.727300, 0.157500,
-0.470227, 0.000000, -0.223608, 0.818200, 0.157500,
-0.500000, 0.154506, 0.000000, 0.772700, 0.236200,
-0.500000, -0.154506, 0.000000, 0.863600, 0.236200,
-0.309017, -0.404508, 0.000000, 0.954500, 0.236200,
-0.380422, -0.262863, 0.223610, 0.909100, 0.314900,
-0.500000, -0.154506, 0.000000, 0.863600, 0.236200,
-0.361802, -0.249998, -0.262868, 0.909100, 0.157500,
-0.309017, -0.404508, 0.000000, 0.954500, 0.236200,
-0.361802, -0.249998, -0.262868, 0.909100, 0.157500,
-0.145306, -0.425325, -0.223610, 1.000000, 0.157500,
-0.309017, -0.404508, 0.000000, 0.954500, 0.236200,
0.000000, -0.500000, 0.000000, 0.136400, 0.236200,
0.309017, -0.404508, 0.000000, 0.227300, 0.236200,
0.145306, -0.425325, 0.223610, 0.181800, 0.314900,
0.000000, -0.500000, 0.000000, 0.136400, 0.236200,
0.138198, -0.404506, -0.262869, 0.181800, 0.157500,
0.309017, -0.404508, 0.000000, 0.227300, 0.236200,
0.138198, -0.404506, -0.262869, 0.181800, 0.157500,
0.380422, -0.262863, -0.223610, 0.272700, 0.157500,
0.309017, -0.404508, 0.000000, 0.227300, 0.236200,
0.500000, -0.154506, 0.000000, 0.318200, 0.236200,
0.500000, 0.154506, 0.000000, 0.409100, 0.236200,
0.470227, 0.000000, 0.223608, 0.363600, 0.314900,
0.500000, -0.154506, 0.000000, 0.318200, 0.236200,
0.447211, 0.000000, -0.262868, 0.363600, 0.157500,
0.500000, 0.154506, 0.000000, 0.409100, 0.236200,
0.447211, 0.000000, -0.262868, 0.363600, 0.157500,
0.380422, 0.262863, -0.223610, 0.454500, 0.157500,
0.500000, 0.154506, 0.000000, 0.409100, 0.236200,
0.223605, 0.154506, -0.425327, 0.500000, 0.078700,
0.138198, 0.404506, -0.262869, 0.545500, 0.157500,
0.380422, 0.262863, -0.223610, 0.454500, 0.157500,
0.223605, 0.154506, -0.425327, 0.500000, 0.078700,
-0.085408, 0.249998, -0.425327, 0.590900, 0.078700,
0.138198, 0.404506, -0.262869, 0.545500, 0.157500,
-0.085408, 0.249998, -0.425327, 0.590900, 0.078700,
-0.145306, 0.425325, -0.223610, 0.636400, 0.157500,
0.138198, 0.404506, -0.262869, 0.545500, 0.157500,
-0.085408, 0.249998, -0.425327, 0.681800, 0.078700,
-0.361802, 0.249998, -0.262868, 0.727300, 0.157500,
-0.145306, 0.425325, -0.223610, 0.636400, 0.157500,
-0.085408, 0.249998, -0.425327, 0.681800, 0.078700,
-0.276392, 0.000000, -0.425326, 0.772700, 0.078700,
-0.361802, 0.249998, -0.262868, 0.727300, 0.157500,
-0.276392, 0.000000, -0.425326, 0.772700, 0.078700,
-0.470227, 0.000000, -0.223608, 0.818200, 0.157500,
-0.361802, 0.249998, -0.262868, 0.727300, 0.157500,
-0.276392, 0.000000, -0.425326, 0.863600, 0.078700,
-0.361802, -0.249998, -0.262868, 0.909100, 0.157500,
-0.470227, 0.000000, -0.223608, 0.818200, 0.157500,
-0.276392, 0.000000, -0.425326, 0.863600, 0.078700,
-0.085408, -0.249998, -0.425327, 0.954500, 0.078700,
-0.361802, -0.249998, -0.262868, 0.909100, 0.157500,
-0.085408, -0.249998, -0.425327, 0.954500, 0.078700,
-0.145306, -0.425325, -0.223610, 1.000000, 0.157500,
-0.361802, -0.249998, -0.262868, 0.909100, 0.157500,
0.447211, 0.000000, -0.262868, 0.363600, 0.157500,
0.223605, 0.154506, -0.425327, 0.409100, 0.078700,
0.380422, 0.262863, -0.223610, 0.454500, 0.157500,
0.447211, 0.000000, -0.262868, 0.363600, 0.157500,
0.223605, -0.154506, -0.425327, 0.318200, 0.078700,
0.223605, 0.154506, -0.425327, 0.409100, 0.078700,
0.223605, -0.154506, -0.425327, 0.318200, 0.078700,
0.000000, 0.000000, -0.500000, 0.363600, 0.000000,
0.223605, 0.154506, -0.425327, 0.409100, 0.078700,
-0.085408, -0.249998, -0.425327, 0.136400, 0.078700,
0.138198, -0.404506, -0.262869, 0.181800, 0.157500,
-0.145306, -0.425325, -0.223610, 0.090900, 0.157500,
-0.085408, -0.249998, -0.425327, 0.136400, 0.078700,
0.223605, -0.154506, -0.425327, 0.227300, 0.078700,
0.138198, -0.404506, -0.262869, 0.181800, 0.157500,
0.223605, -0.154506, -0.425327, 0.227300, 0.078700,
0.380422, -0.262863, -0.223610, 0.272700, 0.157500,
0.138198, -0.404506, -0.262869, 0.181800, 0.157500
	};
	
};


class Mesh //класс оболочки для хранения и обработки геометрической модели (mesh)
{
public:
	//4 самых важных параметра ассета
	bool 	status = false;		//статус конфигурации
	int 	countOfUsers = 1;			//число пользователей этой структуры: если структура создана, значит минимум один пользователь ее ресурсов
	std::string 	name = "default";	//name должен присутствовать всегда, для обеспечения шаблонирования классом asset. Для отчетности
	std::string  type = "mesh";		//type должен присутствовать всегда, для обеспечения шаблонирования классом asset. Для отчетности

	//характеристики конкретно типа меша
	int		meshAttributesCount = 5; 

	//очищаемые параметры
	GLuint 	VBO;
	GLuint 	VAO;
	GLuint 	EBO;

	//стековые параметры
	GLuint 	meshFacesCount = 12;
	GLuint	meshVerticesCount = 36;

	Mesh(std::string newMeshName) : name(newMeshName)
	{
		status = meshLoad();
	}

	~Mesh()
	{
		glDeleteBuffers(1, &VBO);
		glDeleteVertexArrays(1, &VAO);
		glDeleteBuffers(1, &EBO);
	}

	bool meshLoad()
	{
		glGenBuffers(1, &VBO);
		glGenVertexArrays(1, &VAO);

		glBindVertexArray(VAO);
		glBindBuffer(GL_ARRAY_BUFFER, VBO);
		
		
		
		if(name == "SM_Field_01")
		{
			Field_01 field;
			meshFacesCount = field.faces;
			meshVerticesCount = field.vertices;
			glBufferData(GL_ARRAY_BUFFER, 4 * meshVerticesCount * meshAttributesCount, &field.geometry[0], GL_STATIC_DRAW);	//4 байта на флоат для meshAttributesCount флоатов для meshVerticesCount вершин
		}
		
		if(name == "SM_Wall_01")
		{
			Wall_01 wall;
			meshFacesCount = wall.faces;
			meshVerticesCount = wall.vertices;
			glBufferData(GL_ARRAY_BUFFER, 4 * meshVerticesCount * meshAttributesCount, &wall.geometry[0], GL_STATIC_DRAW);	//4 байта на флоат для attributesCount флоатов для ModelVerticesCount вершин
		}
		
		if(name == "SM_Wall_02")
		{
			Wall_02 wall;
			meshFacesCount = wall.faces;
			meshVerticesCount = wall.vertices;
			glBufferData(GL_ARRAY_BUFFER, 4 * meshVerticesCount * meshAttributesCount, &wall.geometry[0], GL_STATIC_DRAW);	//4 байта на флоат для attributesCount флоатов для ModelVerticesCount вершин
		}
		
		if(name == "SM_Carriage_01")
		{
			Carriage_01 carriage;
			meshFacesCount = carriage.faces;
			meshVerticesCount = carriage.vertices;
			glBufferData(GL_ARRAY_BUFFER, 4 * meshVerticesCount * meshAttributesCount, &carriage.geometry[0], GL_STATIC_DRAW);	//4 байта на флоат для attributesCount флоатов для ModelVerticesCount вершин
		}

		if(name == "SM_Block_01")
		{
			Block_01 block;
			meshFacesCount = block.faces;
			meshVerticesCount = block.vertices;
			glBufferData(GL_ARRAY_BUFFER, 4 * meshVerticesCount * meshAttributesCount, &block.geometry[0], GL_STATIC_DRAW);	//4 байта на флоат для attributesCount флоатов для ModelVerticesCount вершин
		}
		
		if(name == "SM_Block_02")
		{
			Block_02 block;
			meshFacesCount = block.faces;
			meshVerticesCount = block.vertices;
			glBufferData(GL_ARRAY_BUFFER, 4 * meshVerticesCount * meshAttributesCount, &block.geometry[0], GL_STATIC_DRAW);	//4 байта на флоат для attributesCount флоатов для ModelVerticesCount вершин
		}
		
		if(name == "SM_Block_03")
		{
			Block_03 block;
			meshFacesCount = block.faces;
			meshVerticesCount = block.vertices;
			glBufferData(GL_ARRAY_BUFFER, 4 * meshVerticesCount * meshAttributesCount, &block.geometry[0], GL_STATIC_DRAW);	//4 байта на флоат для attributesCount флоатов для ModelVerticesCount вершин
		}
		
		if(name == "SM_Block_04")
		{
			Block_04 block;
			meshFacesCount = block.faces;
			meshVerticesCount = block.vertices;
			glBufferData(GL_ARRAY_BUFFER, 4 * meshVerticesCount * meshAttributesCount, &block.geometry[0], GL_STATIC_DRAW);	//4 байта на флоат для attributesCount флоатов для ModelVerticesCount вершин
		}
		
		if(name == "SM_Block_05")
		{
			Block_05 block;
			meshFacesCount = block.faces;
			meshVerticesCount = block.vertices;
			glBufferData(GL_ARRAY_BUFFER, 4 * meshVerticesCount * meshAttributesCount, &block.geometry[0], GL_STATIC_DRAW);	//4 байта на флоат для attributesCount флоатов для ModelVerticesCount вершин
		}
		
		if(name == "SM_Block_06")
		{
			Block_06 block;
			meshFacesCount = block.faces;
			meshVerticesCount = block.vertices;
			glBufferData(GL_ARRAY_BUFFER, 4 * meshVerticesCount * meshAttributesCount, &block.geometry[0], GL_STATIC_DRAW);	//4 байта на флоат для attributesCount флоатов для ModelVerticesCount вершин
		}
		
		if(name == "SM_Block_07")
		{
			Block_07 block;
			meshFacesCount = block.faces;
			meshVerticesCount = block.vertices;
			glBufferData(GL_ARRAY_BUFFER, 4 * meshVerticesCount * meshAttributesCount, &block.geometry[0], GL_STATIC_DRAW);	//4 байта на флоат для attributesCount флоатов для ModelVerticesCount вершин
		}
		
		if(name == "SM_Block_08")
		{
			Block_08 block;
			meshFacesCount = block.faces;
			meshVerticesCount = block.vertices;
			glBufferData(GL_ARRAY_BUFFER, 4 * meshVerticesCount * meshAttributesCount, &block.geometry[0], GL_STATIC_DRAW);	//4 байта на флоат для attributesCount флоатов для ModelVerticesCount вершин
		}
		
		if(name == "SM_Block_09")
		{
			Block_09 block;
			meshFacesCount = block.faces;
			meshVerticesCount = block.vertices;
			glBufferData(GL_ARRAY_BUFFER, 4 * meshVerticesCount * meshAttributesCount, &block.geometry[0], GL_STATIC_DRAW);	//4 байта на флоат для attributesCount флоатов для ModelVerticesCount вершин
		}
		
		if(name == "SM_Ball_01")
		{
			Ball_01 ball;
			meshFacesCount = ball.faces;
			meshVerticesCount = ball.vertices;
			glBufferData(GL_ARRAY_BUFFER, 4 * meshVerticesCount * meshAttributesCount, &ball.geometry[0], GL_STATIC_DRAW);	//4 байта на флоат для attributesCount флоатов для ModelVerticesCount вершин
		}
		
		if(name == "SM_Banner_1024")
		{
			Banner_1024 banner;
			meshFacesCount = banner.faces;
			meshVerticesCount = banner.vertices;
			glBufferData(GL_ARRAY_BUFFER, 4 * meshVerticesCount * meshAttributesCount, &banner.geometry[0], GL_STATIC_DRAW);	//4 байта на флоат для attributesCount флоатов для ModelVerticesCount вершин
		}
		
		
		#define XYZ_ATTRIB 0
		#define UV_ATTRIB 1

		glVertexAttribPointer(XYZ_ATTRIB, 3, GL_FLOAT, GL_FALSE, meshAttributesCount * sizeof(GLfloat), (GLvoid*)0);
		glEnableVertexAttribArray(XYZ_ATTRIB);
		glVertexAttribPointer(UV_ATTRIB, 2, GL_FLOAT, GL_FALSE, meshAttributesCount * sizeof(GLfloat), (GLvoid*)(3 * sizeof(float)));
		glEnableVertexAttribArray(UV_ATTRIB);
		
		glBindVertexArray(0);
		
		return true;
		
	}

	
	void printData()
	{
		printVariable(meshFacesCount)
		printVariable(meshVerticesCount)
	}

	std::string meshGetPath(std::string& filename)
	{
		std::string pathToFile;
#ifdef _WIN32 
		pathToFile = "datas\\meshes\\" + filename + ".ltx";
#elif __linux__
		pathToFile = "./datas/meshes/" + filename + ".ltx";
#else
		pathToFile = "Unknown";
#endif

		return pathToFile;
	}

};


class Shader
{
public:


	//4 самых важных параметра ассета
	bool 	status = false;		//статус конфигурации
	int 	countOfUsers = 1;			//число пользователей этой структуры: если структура создана, значит минимум один пользователь ее ресурсов
	std::string 	name = "default";	//name должен присутствовать всегда, для обеспечения шаблонирования классом asset. Для отчетности
	std::string  type = "shader";		//type должен присутствовать всегда, для обеспечения шаблонирования классом asset. Для отчетности


	std::string vertexShaderFile = "forward.vs";
	std::string fragmentShaderFile = "forward.fs";

	GLuint testShader;

	

	Shader(std::string newShaderName) : name(newShaderName)
	{

		vertexShaderFile = getVShaderPath(name);
		fragmentShaderFile = getFShaderPath(name);

		status = compileNewShader();

		//~ if (status == true)
		//~ {

			//~ //configureUBO();
			//~ //configureUniformAdresses();
		//~ }
	}

	~Shader()
	{


		glDeleteProgram(testShader);
		//glDeleteBuffers(1, &PVMBlock); //очищаем юниформ-блок

		//glDeleteBuffers(1, &skeletonUniformBlock); //очищаем юниформ-блок
		//glDeleteBuffers(1, &lightingUniformBlock); //очищаем юниформ-блок
	}


	void use()
	{
		
	}

	

	bool compileNewShader()//string VertexShader, string FragmentShader)
	{
		//cout << "\tShaders: [" << vertexShaderFile << "] [" << fragmentShaderFile << "]" << endl;
		//приняли адреса файов шейдеров, достаем и компилируем
		//ВЕРШИННЫЙ
		GLuint vShader = glCreateShader(GL_VERTEX_SHADER);			//создаем вершинный шейдер
		std::string VertexShaderCode;
		std::ifstream VertexShaderStream(vertexShaderFile);
		if (VertexShaderStream.is_open())
		{
			std::string Line = "";
			while (getline(VertexShaderStream, Line)) //записываем в VertexShaderStream строки из файла, пока они есть
			{//cout << Line << endl;
				VertexShaderCode += "\n" + Line;
			}
			VertexShaderStream.close();
		}
		else
		{
			//cout << "Cannnot find shader source file: " << vertexShaderFile << endl; 
			VertexShaderStream.close(); return false;
		}

		char const* VertexSourcePointer = VertexShaderCode.c_str();

		glShaderSource(vShader, 1, &VertexSourcePointer, NULL);		//назначем ему код по указателю vertexShaderSource //glShaderSource(vShader, 1, &vertexShaderSource, NULL);
		glCompileShader(vShader);									//компилируем
		//shadCheckShaderCompileStatus(vShader);							//проверяем

		//ФРАГМЕНТНЫЙ
		GLuint fShader = glCreateShader(GL_FRAGMENT_SHADER);		//создаем фрагментный шейдер

		std::string FragmentShaderCode;
		std::ifstream FragmentShaderStream(fragmentShaderFile);
		if (FragmentShaderStream.is_open())
		{
			std::string Line2 = "";
			while (getline(FragmentShaderStream, Line2)) //записываем в FragmentShaderStream строки из файла, пока они есть
			{//cout << Line2 << endl;
				FragmentShaderCode += "\n" + Line2;
			}
			FragmentShaderStream.close();
		}
		else { //cout << "Cannnot find shader source file: " << fragmentShaderFile << endl; 
			FragmentShaderStream.close(); return false; }
		char const* FragmentSourcePointer = FragmentShaderCode.c_str();

		glShaderSource(fShader, 1, &FragmentSourcePointer, NULL);   //glShaderSource(fShader, 1, &fragmentShaderSource, NULL);
		glCompileShader(fShader);									//компилируем
		//shadCheckShaderCompileStatus(fShader);							//проверяем

		//СОЗДАЕМ ПРОГРАММУ
		testShader = glCreateProgram();							//создаем программу
		glAttachShader(testShader, vShader);							//присоединяем к программе вершинный шейдер
		glAttachShader(testShader, fShader);							//и фрагментный
		//glAttachShader(program, gShader);
		glLinkProgram(testShader);										//линкуем
		//glUseProgram(program);										//начинаем использовать
		GLint status;
		glGetProgramiv(testShader, GL_LINK_STATUS, &status);			//получаем статус программы

		glDeleteShader(vShader);
		glDeleteShader(fShader);

		if (status == GL_FALSE)										//проверяем статус программы
		{
			GLint infoLogLength;
			glGetProgramiv(testShader, GL_INFO_LOG_LENGTH, &infoLogLength);
			GLchar* infoLog = new GLchar[infoLogLength];
			glGetProgramInfoLog(testShader, infoLogLength, NULL, infoLog);
			std::cerr << "Link log 2: " << infoLog << std::endl;
			delete[] infoLog;
			return false;
		}
		else
		{
			return true;
		}


		//glDeleteShader(gShader);


		//VertexShaderStream.close();
		//FragmentShaderStream.close();
		//GeometryShaderStream.close();

		//return program;
	}

	std::string getVShaderPath(std::string Name)
	{
		std::string pathToFile;
#ifdef _WIN32 
		pathToFile = "datas\\shaders\\" + Name + ".vs";
#elif __linux__
		pathToFile = "./datas/shaders/" + Name + ".vs";
#else
		pathToFile = "Unknown";
#endif

		return pathToFile;
	}

	std::string getFShaderPath(std::string Name)
	{
		std::string pathToFile;
#ifdef _WIN32 
		pathToFile = "datas\\shaders\\" + Name + ".fs";
#elif __linux__
		pathToFile = "./datas/shaders/" + Name + ".fs";
#else
		pathToFile = "Unknown";
#endif

		return pathToFile;
	}


	void printData()
	{
		//cout << "\t\t\t Shadername: " << name << endl;
		//cout << "\t\t\t Verts: " << ModelVerticesCount << endl;
		//if (skeletalMesh) { cout << "\t\t\t\t Skeleton: yes - " << skeletonName << endl; }
	}


};


class Texture	//класс оболочки для хранения материала (массива текстур 2Д)
{
public:
	//4 самых важных параметра ассета
	bool 	status = false;		//статус конфигурации
	int 	countOfUsers = 1;			//число пользователей этой структуры: если структура создана, значит минимум один пользователь ее ресурсов
	std::string 	name = "default";	//name должен присутствовать всегда, для обеспечения шаблонирования классом asset. Для отчетности
	std::string  type = "image";		//type должен присутствовать всегда, для обеспечения шаблонирования классом asset. Для отчетности

	GLuint 	texture2D;
	glm::ivec2	textureSize = glm::ivec2(128, 128);
	int		textureColorChannels = 4;

	Texture(std::string newImageName)// : name(newImageName)
	{
		name = getImagePath(newImageName);

		status = createTextureUnit();
	}

	~Texture()
	{
		glDeleteTextures(1, &texture2D);
	}

	bool createTextureUnit()
	{
		glGenTextures(1, &texture2D);
		glBindTexture(GL_TEXTURE_2D, texture2D);
		// set the texture wrapping/filtering options (on the currently bound texture object)
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		// load and generate the texture
		int width, height, nrChannels;
		width = 1024;
		height = 1024;
		nrChannels = 1;

		stbi_set_flip_vertically_on_load(true);
		
		unsigned char* data = stbi_load(name.c_str(), &width, &height, &nrChannels, STBI_default);
		if (data)
		{
			//glTexImage3D(GL_TEXTURE_2D_ARRAY, 0, 0, 0, currentlayer, textureSize.x, textureSize.y, 1, GL_RGBA, GL_UNSIGNED_BYTE, data);
			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
			glGenerateMipmap(GL_TEXTURE_2D);
			stbi_image_free(data);
			return true;
		}
		else
		{
			stbi_image_free(data);
			return false;
		}
	}

	


	std::string getImagePath(std::string Name)
	{
		std::string pathToFile;

		if (getOperationSystem() == "Windows") { pathToFile = "datas\\textures\\" + Name + ""; }//pathToFile = "datas\\textures\\"+Name+".png";	}

		if (getOperationSystem() == "Linux") { pathToFile = "./datas/textures/" + Name + ""; }//"./datas/textures/"+Name+".png";	}

		return pathToFile;
	}

};

template <class T>
class Asset	//шаблонный класс, содержащий методы для загрузки и выгрузки ресурсов
{
public:
	~Asset() //автоматическое удаление всех существующих экземпляров объектов
	{
		for (auto pObj : existedObjects) { delete pObj.second; }		//проход по карте с удалением объектов по хранимым в этой карте указателям и очистка самой карты
		existedObjects.clear();
	}

	//пытаться добавить новые объекты можно сколько угодно. При наличии уже имеющихся дубликатов этого не произойдет
	T* addObject(std::string& sysName, std::string& newObjectName) //сохранение в вектор новых экземпляров объектов
	{
		if (existedObjects.count(newObjectName) != 0) //если объектов с заданным именем в словаре больше нуля, значит объект уже существует
		{
			//найден дубликат, инкрементируем число пользователей этого ресурса и вернем указатель на него
			existedObjects[newObjectName]->countOfUsers++;	
			return existedObjects[newObjectName];
		}
		else //если объект не найден, то
		{
			T* newObject = new T(newObjectName);	//создадим новый экземпляр

			if (newObject->status)		//если экземпляр загружен правильно, то
			{
				existedObjects[newObjectName] = newObject;	//внесем его в словарь
				return newObject;
			}
			else
			{
				delete newObject;	//если какая то ошибка - удалим бракованный экземпляр за ненадобностью
				printVarComment("Cannot create asset: ", newObjectName )
				return nullptr;		//вернем нулевой указатель
			}
		}
	}

	void deleteObject(std::string targetName)	//удаление происходит только если число пользователей меньше 1 - в ином случае просто уменьшается число пользователей
	{
		//в словаре - только уникальные объекты
		if (existedObjects.count(targetName) != 0) //проверка, существует ли вообще объект с заданным именем
		{
			if (existedObjects[targetName]->countOfUsers > 1) //проверяется количество пользователей, если оно больше 1, то декрементируется число пользователей
			{
				existedObjects[targetName]->countOfUsers--;
			}
			else //а если объект - единственный, то удалить совсем
			{
				delete existedObjects[targetName];
				existedObjects.erase(targetName);
			}
		}
		//при попытке удалить несуществующий объект не произойдет ничего
	}

	T* getObjectByName(std::string targetName)
	{		
		return existedObjects.count(targetName) != 0 ? existedObjects[targetName] : nullptr ;	//вернем указатель на найденный объект либо nullptr
	}

	//~ void showList(string type)
	//~ {
		//~ if (!existedObjects.empty())
		//~ {
			//~ int serialnumber = 0;
			//~ cout << "\nPrinting existing " << type << endl;
			//~ for (auto pObj : existedObjects)
			//~ {
				//~ cout << "\t" << serialnumber << ") Object '" << pObj.second->Name << "', used times: " << pObj.second->countOfUsers << endl; 	pObj.second->printData(); serialnumber++;
			//~ }
		//~ }
		//~ else { cout << "\nNo such assets! " << endl; }
	//~ }

private:
	std::map <std::string, T*> 	existedObjects;//доступ к карте с указателями на объекты осуществляется только через публичные функции addObject/deleteObject, во избежание утечек
};


Asset <Mesh> 			Meshes;
Asset <Shader> 			Shaders;
Asset <Texture>			Textures;

int TICK = 1; //миллисекунд с прошлого кадра
int TACK = 1; //миллисекунд с прошлого касания стенки

typedef bool (*MyFunc)(void*); //typedef void (*MyFunc)(); - для простых void-ов
//этот секвенсер будет подмешивать в поток цикла привязанные функции, причем заведомо однократно

static bool sequencerFuncTemplate(void* ptr)
{
	static int timer = 0;

	// здесь задаем максимальное время выполнения скрипта, к примеру, скрипт будет выполняться в течение 60 кадров
#define scriptLivingTimer 60

//прописываем тайминги событий
	if (timer == 0)
	{
	}

	if (timer == scriptLivingTimer / 2)
	{
	}

	if (timer == scriptLivingTimer)
	{
		//--script for ending this func

		//----------
		timer = 0;
		return true;	//функция выполнилась до конца
	}
	else
	{
		timer++;
		return false;	//функция еще не выполнена
	}

}

class Sequencer
{
public:
	Sequencer() { }

	struct SequenceShell
	{
		SequenceShell(std::string name, MyFunc event, void* clas, bool* resultTarget = nullptr) //обертка привязываемой последовательности: имя функции, адрес функции, адрес класса, откуда функция, указатель на флаг завершенности функции 
		{
			eventName = name;
			bindedEvent = event;
			bindedClass = clas;
			if (resultTarget != nullptr) { report = resultTarget; } //resultTarget иногда может быть nullptr (для необязательности его упоминания в аргументах), потому добавляем проверку
		}

		std::string eventName = "foo";
		MyFunc bindedEvent;
		void* bindedClass;
		bool* report = nullptr; //указатель на флаг завершенности действия
	};

	std::vector <SequenceShell> sequences;


	void CallSequence(SequenceShell newSequence)	//string name, MyFunc event, void* clas, bool unbinding
	{
		//cout << "Call sequence: " << newSequence.eventName << endl;
		//cout << "\t Owner class: " << newSequence.bindedClass << endl;
		sequences.push_back(newSequence);
	}

	//функция Execute() должна вызываться в каждом игровом цикле
	void Execute()	//вызывать диспетчером все подписанные функции, хранящиеся в словаре bindedEvents
	{
		int i = 0;
		for (auto sequence : sequences)
		{
			bool result = sequences[i].bindedEvent(sequences[i].bindedClass);

			if (result) //если конкретная последовательность выполнена успешно, то отвязываем ее из потока
			{
				if (sequences[i].report != nullptr) { *sequences[i].report = true; } //report из обртки функции иногда может быть nullptr, потому добавляем проверку и сигналим об успехе
				sequences.erase(sequences.cbegin() + i);
			}
			i++;
		}
	}

	~Sequencer()
	{
		sequences.clear(); //так как словарь оперирует лишь указателями, то с самими указателями ничего делать не нужно - они обрабатываются в своих собственных классах. Достаточно очистить словарь
	}
};

Sequencer Flow;	//Flow - списки функций, подписанные на некие триггеры. Это способ запускать цепочки событий, прописанных в подписанных функциях



class Entity
{
	// сущность для собственного воплощения набирает из списка ассетов: модель, текстуру, шейдер
public:
	
	Entity(std::string sysname, glm::vec3 localPosition, glm::quat localRotation, std::string meshName, std::string textureName, std::string shaderName="defaultShader")
	{
		entitySysname 		= sysname;
		entityPosition		= localPosition;
		entityRotation		= localRotation;
		entityMeshName		= meshName;
		entityTextureName 	= textureName;
		if(shaderName != "defaultShader") {	entityShaderName = shaderName;	}
		
		status = configureEntity();
	}
	
	bool status						= false;
	bool visible					= true;
	std::string entitySysname 		= "default";
	glm::vec3 entityPosition 		= glm::vec3(0,0,0);
	glm::quat entityRotation 		= glm::quat(1,0,0,0);
	std::string entityMeshName		= "defaultMesh";
	std::string entityTextureName	= "defaultTexture";
	std::string entityShaderName	= "defaultShader";
	
	glm::vec3 entityColor			= glm::vec3(1,0,0);
	
	//указатели, которым необходимо присвоить адреса. Они очищаются в менеджере ассетов, так что в деструкторе Entity их напрямую удалять не нужно, только через deleteObject!
	Mesh* 		entityMesh 		= nullptr;			//указатель на экземпляр класса модели - надо найти эту модель в списке ассетов и скопировать указатель сюда    
	Shader* 	entityShader 	= nullptr;			//указатель на экземпляр класса шейдера - надо найти этот шейдер в списке ассетов и скопировать указатель сюда. Нужен для обеспечения возможности отрисовывать каждую сущность по-разному
	Texture* 	entityTexture 	= nullptr;
		
	bool configureEntity()
	{
		entityMesh = Meshes.addObject(entitySysname, entityMeshName);	//менеджер ассетов в любом случае вернет ссылку на объект класса модели, разница лишь в том, будет ли создан новый или вернется ссылка на оригинал		
		//по-хорошему entityMesh не может быть nullptr,  ибо в случае отсутствия дубликатов создастся новый объект, но проверку стоит оставлять
		bool meshStatus = entityMesh != nullptr ? true : false;
		
		
		entityShader = Shaders.addObject(entitySysname, entityShaderName);
		bool shaderStatus = entityShader != nullptr ? true : false;
		
		entityTexture = Textures.addObject(entitySysname, entityTextureName);
		bool textureStatus = entityTexture != nullptr ? true : false;
		
		if(meshStatus && shaderStatus && textureStatus) {return true;}
		else {	printMessage("Error! Cannot take mesh, shader or texture!") return false;	}
	}
	
	
	~Entity()
	{
		//очистка модели
		Meshes.deleteObject(entityMeshName);	//при удалении игрового объекта если пользователей больше 1, то лишь декрементируется их число. А если всего один - то полностью удалится
		//entityMesh не удаляем через delete, потому что эта модель может использоваться где то еще. Удаляем через Meshes.deleteObject(entityMeshName) - этот метод все проверит сам

		//очистка шейдеров
		Shaders.deleteObject(entityShaderName);
		
		//очистка текстур
		Textures.deleteObject(entityTextureName);
	}
};


class Set
{
	// сет это набор сущностей и логики их взаимодействия, представлящий единый микромир в контексте глобального игрового мира
public:	
	std::map <std::string, Entity*> components;
	
public:

	bool visible = true;
	bool collision = true;
	
	int colorable = 1;
	
	int haveBonus = 0;
	int autoPilot = 0;
	
	glm::vec3 worldLocation = glm::vec3(0,0,0);
	glm::quat worldRotation	= glm::quat(1,0,0,0);

	glm::mat4 ProjViewMatrix = glm::mat4(1.0);

	std::string previosShaderName = "none";

	std::vector <glm::mat4> AABB;

	std::string setType = "Set";

	virtual ~Set() 
	{
		for(auto comp : components) { delete comp.second;}	//очистка всех Entity* через их собственные деструкторы
		components.clear();									//очистка словаря сущностей
		
		AABB.clear();
	}
	
	bool addEntity(std::string entitySysname, glm::vec3 entityLocalPosition, glm::quat entityLocalRotation, std::string entityMeshName, std::string entityTextureName, std::string entityShaderName = "defaultShader")
	{
		Entity* newComponent = new Entity(entitySysname, entityLocalPosition, entityLocalRotation, entityMeshName, entityTextureName, entityShaderName );	//создать объект класса Entity
		
		if (newComponent->status) {components[entitySysname] = newComponent; 		return true; }	//если объект сконфигурирован удачно, занести в список компонентов
		else { printMessage("Error! Cannot create entity!\n") delete newComponent; 	return false;}	//если возникла ошибка, вывести предупреждение и удалить косячный объект
	}
	
	
	
	void renderPrimaryEntity(Entity* entity, glm::vec3 entityPosition, glm::quat entityRotation)
	{
		if (entity->entityShaderName != previosShaderName)
		{
			previosShaderName = entity->entityShaderName; //
			//~ std::cout << "\t\t Change shader\n";
			glUseProgram(entity->entityShader->testShader);
		}

	



		//PVM
		glm::mat4 matrix = glm::mat4(1.0);
		matrix = translate(matrix, worldLocation + worldRotation * entity->entityPosition);//перенос сущности по x y z в точку мирового пространства
		glm::mat4 rot = glm::mat4_cast(worldRotation * entity->entityRotation);
		matrix *= rot;
		
		//~ if(setType == "Camera")
		//~ {
			//~ //printMessage("Camera")
			//~ ProjViewMatrix = glm::ortho(-1.0f, 1.0f, )
			
		//~ }
		
		glUniformMatrix4fv(glGetUniformLocation(entity->entityShader->testShader, "M"), 1, GL_FALSE, &matrix[0][0]);
		glUniformMatrix4fv(glGetUniformLocation(entity->entityShader->testShader, "PV"), 1, GL_FALSE, &ProjViewMatrix[0][0]);
		//glUniform3fv(glGetUniformLocation(entity->entityShader->testShader, "color"), 1, &entity->entityColor[0] );
		
		

		glUniform3fv(glGetUniformLocation(entity->entityShader->testShader, "color"), 1, &entity->entityColor[0]);
		

		//int hasLightmap = entity->entityLighmapName != "none" ? 1 : 0;	//по умолчанию ни один объект не имеет карты света

		glUniform1i(glGetUniformLocation(entity->entityShader->testShader, "colorable"), colorable);
		
		glUniform1i(glGetUniformLocation(entity->entityShader->testShader, "haveBonus"), haveBonus);	
		glUniform1i(glGetUniformLocation(entity->entityShader->testShader, "autopilotBonus"), autoPilot);	
			

		//

		if (entity->entityTexture != nullptr)
		{
			//glUniform1i(glGetUniformLocation(entity->entityShader->testShader, "Texture"), 1);

			glBindTextureUnit(10, entity->entityTexture->texture2D);
			glUniform1i(glGetUniformLocation(entity->entityShader->testShader, "Texture"), 10);

			//std::cout << "texture\n";
			//glBindTextureUnit(19, entity->entityLightmap->texture2D);
			//glBindTexture(GL_TEXTURE_2D, entity->entityLightmap->texture2D);
			//glUniform1i(glGetUniformLocation(entity->entityShader->testShader, "LIGHTMAP_IMAGE"), entity->entityLightmap->texture2D);
			//cout << SET_Name << " , " << entity->entityMeshName << ", lightmap:" << entity->entityLightmapName << endl;
		}
		

		glBindVertexArray(entity->entityMesh->VAO);
		#define VERTEXES_COUNT entity->entityMesh->meshVerticesCount
		glDrawArrays(GL_TRIANGLES, 0, VERTEXES_COUNT);
		glBindVertexArray(0);
	}

	virtual void init() {}

	virtual void update() 	{}

	void render(glm::mat4& PVmatrix)
	{
		ProjViewMatrix = PVmatrix;
		
		if (!components.empty())
		{
			for (auto entity : components) // Entity*
			{
				if(entity.second->visible)
				{
					renderPrimaryEntity(entity.second, entity.second->entityPosition, entity.second->entityRotation);
				}
			}
		}
	}
	
};


class Field : public Set
{	//класс, описывающий облик игрового поля
public:
	Field(glm::vec3 worldLoc = glm::vec3(0, 0, 0), glm::quat worldRot = glm::quat(1, 0, 0, 0))
	{
		//printMessage("create field")
		worldLocation = worldLoc;		//назначим координаты
		worldRotation = worldRot;
		
		setType = "Field";
		
		addEntity("GameField", 	glm::vec3(0, 0, 0), 		glm::quat(1, 0, 0, 0),			"SM_Field_01", 	"wood_table_001_diff_2k.png" );
		addEntity("Wall_left", 	glm::vec3(-25, 7.5, 0.5), 	glm::quat(0.707, 0, 0, 0.707), 	"SM_Wall_01", 	"raw_plank_wall_diff_2k.png" );
		addEntity("Wall_right", glm::vec3(25, 7.5, 0.5), 	glm::quat(0.707, 0, 0, 0.707), 	"SM_Wall_01", 	"raw_plank_wall_diff_2k.png" );
		addEntity("Wall_up", 	glm::vec3(0, 30, 0.5), 		glm::quat(1, 0, 0, 0), 			"SM_Wall_02", 	"raw_plank_wall_diff_2k.png" );
		
		
		AABB = {
				
glm::mat4(
glm::vec4( -24.950108, 0.001816, 1.000001, 0),
glm::vec4( -25.050106, 0.001816, 0.000001, 0),
glm::vec4( -24.950108, 0.001816, 0.000001, 0),
glm::vec4( 0.000000, -1.000000, 0.000000, 0) ),
glm::mat4(
glm::vec4( -25.050106, 0.001816, 1.000001, 0),
glm::vec4( -25.050104, 30.001816, 0.000001, 0),
glm::vec4( -25.050106, 0.001816, 0.000001, 0),
glm::vec4( -1.000000, 0.000000, 0.000000, 0) ),
glm::mat4(
glm::vec4( -25.050104, 30.001816, 1.000001, 0),
glm::vec4( -24.950106, 30.001816, 0.000001, 0),
glm::vec4( -25.050104, 30.001816, 0.000001, 0),
glm::vec4( 0.000000, 1.000000, -0.000000, 0) ),
glm::mat4(
glm::vec4( -24.950106, 30.001816, 1.000001, 0),
glm::vec4( -24.950108, 0.001816, 0.000001, 0),
glm::vec4( -24.950106, 30.001816, 0.000001, 0),
glm::vec4( 1.000000, -0.000000, 0.000000, 0) ),
glm::mat4(
glm::vec4( -25.050104, 30.001816, 0.000001, 0),
glm::vec4( -24.950108, 0.001816, 0.000001, 0),
glm::vec4( -25.050106, 0.001816, 0.000001, 0),
glm::vec4( 0.000000, 0.000000, -1.000000, 0) ),
glm::mat4(
glm::vec4( -25.050106, 0.001816, 1.000001, 0),
glm::vec4( -24.950106, 30.001816, 1.000001, 0),
glm::vec4( -25.050104, 30.001816, 1.000001, 0),
glm::vec4( -0.000000, 0.000000, 1.000000, 0) ),
glm::mat4(
glm::vec4( -24.950108, 0.001816, 1.000001, 0),
glm::vec4( -25.050106, 0.001816, 1.000001, 0),
glm::vec4( -25.050106, 0.001816, 0.000001, 0),
glm::vec4( 0.000000, -1.000000, 0.000000, 0) ),
glm::mat4(
glm::vec4( -25.050106, 0.001816, 1.000001, 0),
glm::vec4( -25.050104, 30.001816, 1.000001, 0),
glm::vec4( -25.050104, 30.001816, 0.000001, 0),
glm::vec4( -1.000000, 0.000000, 0.000000, 0) ),
glm::mat4(
glm::vec4( -25.050104, 30.001816, 1.000001, 0),
glm::vec4( -24.950106, 30.001816, 1.000001, 0),
glm::vec4( -24.950106, 30.001816, 0.000001, 0),
glm::vec4( 0.000000, 1.000000, -0.000000, 0) ),
glm::mat4(
glm::vec4( -24.950106, 30.001816, 1.000001, 0),
glm::vec4( -24.950108, 0.001816, 1.000001, 0),
glm::vec4( -24.950108, 0.001816, 0.000001, 0),
glm::vec4( 1.000000, -0.000000, 0.000000, 0) ),
glm::mat4(
glm::vec4( -25.050104, 30.001816, 0.000001, 0),
glm::vec4( -24.950106, 30.001816, 0.000001, 0),
glm::vec4( -24.950108, 0.001816, 0.000001, 0),
glm::vec4( 0.000000, 0.000000, -1.000000, 0) ),
glm::mat4(
glm::vec4( -25.050106, 0.001816, 1.000001, 0),
glm::vec4( -24.950108, 0.001816, 1.000001, 0),
glm::vec4( -24.950106, 30.001816, 1.000001, 0),
glm::vec4( 0.000000, 0.000000, 1.000000, 0) ),
glm::mat4(
glm::vec4( 25.049885, 0.001814, 1.000001, 0),
glm::vec4( 24.949886, 0.001814, 0.000001, 0),
glm::vec4( 25.049885, 0.001814, 0.000001, 0),
glm::vec4( 0.000000, -1.000000, 0.000000, 0) ),
glm::mat4(
glm::vec4( 24.949886, 0.001814, 1.000001, 0),
glm::vec4( 24.949886, 30.001812, 0.000001, 0),
glm::vec4( 24.949886, 0.001814, 0.000001, 0),
glm::vec4( -1.000000, 0.000000, 0.000000, 0) ),
glm::mat4(
glm::vec4( 24.949886, 30.001812, 1.000001, 0),
glm::vec4( 25.049889, 30.001812, 0.000001, 0),
glm::vec4( 24.949886, 30.001812, 0.000001, 0),
glm::vec4( 0.000000, 1.000000, -0.000000, 0) ),
glm::mat4(
glm::vec4( 25.049889, 30.001812, 1.000001, 0),
glm::vec4( 25.049885, 0.001814, 0.000001, 0),
glm::vec4( 25.049889, 30.001812, 0.000001, 0),
glm::vec4( 1.000000, -0.000000, 0.000000, 0) ),
glm::mat4(
glm::vec4( 24.949886, 30.001812, 0.000001, 0),
glm::vec4( 25.049885, 0.001814, 0.000001, 0),
glm::vec4( 24.949886, 0.001814, 0.000001, 0),
glm::vec4( 0.000000, 0.000000, -1.000000, 0) ),
glm::mat4(
glm::vec4( 24.949886, 0.001814, 1.000001, 0),
glm::vec4( 25.049889, 30.001812, 1.000001, 0),
glm::vec4( 24.949886, 30.001812, 1.000001, 0),
glm::vec4( -0.000000, 0.000000, 1.000000, 0) ),
glm::mat4(
glm::vec4( 25.049885, 0.001814, 1.000001, 0),
glm::vec4( 24.949886, 0.001814, 1.000001, 0),
glm::vec4( 24.949886, 0.001814, 0.000001, 0),
glm::vec4( 0.000000, -1.000000, 0.000000, 0) ),
glm::mat4(
glm::vec4( 24.949886, 0.001814, 1.000001, 0),
glm::vec4( 24.949886, 30.001812, 1.000001, 0),
glm::vec4( 24.949886, 30.001812, 0.000001, 0),
glm::vec4( -1.000000, 0.000000, 0.000000, 0) ),
glm::mat4(
glm::vec4( 24.949886, 30.001812, 1.000001, 0),
glm::vec4( 25.049889, 30.001812, 1.000001, 0),
glm::vec4( 25.049889, 30.001812, 0.000001, 0),
glm::vec4( 0.000000, 1.000000, -0.000000, 0) ),
glm::mat4(
glm::vec4( 25.049889, 30.001812, 1.000001, 0),
glm::vec4( 25.049885, 0.001814, 1.000001, 0),
glm::vec4( 25.049885, 0.001814, 0.000001, 0),
glm::vec4( 1.000000, -0.000000, 0.000000, 0) ),
glm::mat4(
glm::vec4( 24.949886, 30.001812, 0.000001, 0),
glm::vec4( 25.049889, 30.001812, 0.000001, 0),
glm::vec4( 25.049885, 0.001814, 0.000001, 0),
glm::vec4( 0.000000, 0.000000, -1.000000, 0) ),
glm::mat4(
glm::vec4( 24.949886, 0.001814, 1.000001, 0),
glm::vec4( 25.049885, 0.001814, 1.000001, 0),
glm::vec4( 25.049889, 30.001812, 1.000001, 0),
glm::vec4( 0.000000, 0.000000, 1.000000, 0) ),
glm::mat4(
glm::vec4( -25.000107, 29.951818, 1.000001, 0),
glm::vec4( -25.000105, 30.051819, 0.000001, 0),
glm::vec4( -25.000107, 29.951818, 0.000001, 0),
glm::vec4( -1.000000, 0.000019, 0.000000, 0) ),
glm::mat4(
glm::vec4( -25.000105, 30.051819, 1.000001, 0),
glm::vec4( 24.999886, 30.051811, 0.000001, 0),
glm::vec4( -25.000105, 30.051819, 0.000001, 0),
glm::vec4( 0.000000, 1.000000, 0.000000, 0) ),
glm::mat4(
glm::vec4( 24.999886, 30.051811, 1.000001, 0),
glm::vec4( 24.999886, 29.951813, 0.000001, 0),
glm::vec4( 24.999886, 30.051811, 0.000001, 0),
glm::vec4( 1.000000, 0.000000, -0.000000, 0) ),
glm::mat4(
glm::vec4( 24.999886, 29.951813, 1.000001, 0),
glm::vec4( -25.000107, 29.951818, 0.000001, 0),
glm::vec4( 24.999886, 29.951813, 0.000001, 0),
glm::vec4( -0.000000, -1.000000, 0.000000, 0) ),
glm::mat4(
glm::vec4( 24.999886, 30.051811, 0.000001, 0),
glm::vec4( -25.000107, 29.951818, 0.000001, 0),
glm::vec4( -25.000105, 30.051819, 0.000001, 0),
glm::vec4( 0.000000, -0.000000, -1.000000, 0) ),
glm::mat4(
glm::vec4( -25.000105, 30.051819, 1.000001, 0),
glm::vec4( 24.999886, 29.951813, 1.000001, 0),
glm::vec4( 24.999886, 30.051811, 1.000001, 0),
glm::vec4( 0.000000, 0.000000, 1.000000, 0) ),
glm::mat4(
glm::vec4( -25.000107, 29.951818, 1.000001, 0),
glm::vec4( -25.000105, 30.051819, 1.000001, 0),
glm::vec4( -25.000105, 30.051819, 0.000001, 0),
glm::vec4( -1.000000, 0.000019, 0.000000, 0) ),
glm::mat4(
glm::vec4( -25.000105, 30.051819, 1.000001, 0),
glm::vec4( 24.999886, 30.051811, 1.000001, 0),
glm::vec4( 24.999886, 30.051811, 0.000001, 0),
glm::vec4( 0.000000, 1.000000, -0.000000, 0) ),
glm::mat4(
glm::vec4( 24.999886, 30.051811, 1.000001, 0),
glm::vec4( 24.999886, 29.951813, 1.000001, 0),
glm::vec4( 24.999886, 29.951813, 0.000001, 0),
glm::vec4( 1.000000, 0.000000, 0.000000, 0) ),
glm::mat4(
glm::vec4( 24.999886, 29.951813, 1.000001, 0),
glm::vec4( -25.000107, 29.951818, 1.000001, 0),
glm::vec4( -25.000107, 29.951818, 0.000001, 0),
glm::vec4( -0.000000, -1.000000, 0.000000, 0) ),
glm::mat4(
glm::vec4( 24.999886, 30.051811, 0.000001, 0),
glm::vec4( 24.999886, 29.951813, 0.000001, 0),
glm::vec4( -25.000107, 29.951818, 0.000001, 0),
glm::vec4( 0.000000, 0.000000, -1.000000, 0) ),
glm::mat4(
glm::vec4( -25.000105, 30.051819, 1.000001, 0),
glm::vec4( -25.000107, 29.951818, 1.000001, 0),
glm::vec4( 24.999886, 29.951813, 1.000001, 0),
glm::vec4( 0.000000, -0.000000, 1.000000, 0) )

		};
	}
};


class Carriage : public Set
{	//класс, описывающий облик каретки
public:
	Carriage(glm::vec3 worldLoc = glm::vec3(0, 0, 0), glm::quat worldRot = glm::quat(1, 0, 0, 0))
	{
		//printMessage("create field")
		worldLocation = worldLoc;		//назначим координаты
		worldRotation = worldRot;
		
		setType = "Carriage";
		
		addEntity("Carriage", 	glm::vec3(0, 0, 0), 		glm::quat(1, 0, 0, 0),			"SM_Carriage_01", 	"raw_plank_wall_diff_2k.png" );
		
		AABB = {
			glm::mat4(
			glm::vec4( -1.500000, -0.500000, 1.000000, 0),
			glm::vec4( -1.500000, 0.500000, 0.000000, 0),
			glm::vec4( -1.500000, -0.500000, 0.000000, 0),
			glm::vec4( -1.000000, 0.000000, 0.000000, 0) ),
			glm::mat4(
			glm::vec4( -1.500000, 0.500000, 1.000000, 0),
			glm::vec4( 1.500000, 0.500000, 0.000000, 0),
			glm::vec4( -1.500000, 0.500000, 0.000000, 0),
			glm::vec4( 0.000000, 1.000000, -0.000000, 0) ),
			glm::mat4(
			glm::vec4( 1.500000, 0.500000, 1.000000, 0),
			glm::vec4( 1.500000, -0.500000, 0.000000, 0),
			glm::vec4( 1.500000, 0.500000, 0.000000, 0),
			glm::vec4( 1.000000, 0.000000, -0.000000, 0) ),
			glm::mat4(
			glm::vec4( 1.500000, -0.500000, 1.000000, 0),
			glm::vec4( -1.500000, -0.500000, 0.000000, 0),
			glm::vec4( 1.500000, -0.500000, 0.000000, 0),
			glm::vec4( 0.000000, -1.000000, 0.000000, 0) ),
			glm::mat4(
			glm::vec4( 1.500000, 0.500000, 0.000000, 0),
			glm::vec4( -1.500000, -0.500000, 0.000000, 0),
			glm::vec4( -1.500000, 0.500000, 0.000000, 0),
			glm::vec4( 0.000000, 0.000000, -1.000000, 0) ),
			glm::mat4(
			glm::vec4( -1.500000, 0.500000, 1.000000, 0),
			glm::vec4( 1.500000, -0.500000, 1.000000, 0),
			glm::vec4( 1.500000, 0.500000, 1.000000, 0),
			glm::vec4( 0.000000, 0.000000, 1.000000, 0) ),
			glm::mat4(
			glm::vec4( -1.500000, -0.500000, 1.000000, 0),
			glm::vec4( -1.500000, 0.500000, 1.000000, 0),
			glm::vec4( -1.500000, 0.500000, 0.000000, 0),
			glm::vec4( -1.000000, 0.000000, 0.000000, 0) ),
			glm::mat4(
			glm::vec4( -1.500000, 0.500000, 1.000000, 0),
			glm::vec4( 1.500000, 0.500000, 1.000000, 0),
			glm::vec4( 1.500000, 0.500000, 0.000000, 0),
			glm::vec4( 0.000000, 1.000000, -0.000000, 0) ),
			glm::mat4(
			glm::vec4( 1.500000, 0.500000, 1.000000, 0),
			glm::vec4( 1.500000, -0.500000, 1.000000, 0),
			glm::vec4( 1.500000, -0.500000, 0.000000, 0),
			glm::vec4( 1.000000, 0.000000, 0.000000, 0) ),
			glm::mat4(
			glm::vec4( 1.500000, -0.500000, 1.000000, 0),
			glm::vec4( -1.500000, -0.500000, 1.000000, 0),
			glm::vec4( -1.500000, -0.500000, 0.000000, 0),
			glm::vec4( 0.000000, -1.000000, 0.000000, 0) ),
			glm::mat4(
			glm::vec4( 1.500000, 0.500000, 0.000000, 0),
			glm::vec4( 1.500000, -0.500000, 0.000000, 0),
			glm::vec4( -1.500000, -0.500000, 0.000000, 0),
			glm::vec4( 0.000000, 0.000000, -1.000000, 0) ),
			glm::mat4(
			glm::vec4( -1.500000, 0.500000, 1.000000, 0),
			glm::vec4( -1.500000, -0.500000, 1.000000, 0),
			glm::vec4( 1.500000, -0.500000, 1.000000, 0),
			glm::vec4( 0.000000, -0.000000, 1.000000, 0) ),

			};
	}
};


class Ball : public Set
{	//класс, описывающий облик каретки
public:
	Ball(glm::vec3 worldLoc = glm::vec3(0, 0, 0), glm::quat worldRot = glm::quat(1, 0, 0, 0))
	{
		//printMessage("create field")
		worldLocation = worldLoc;		//назначим координаты
		worldRotation = worldRot;
		
		setType = "Ball";
		
		addEntity("Ball_01", 	glm::vec3(0, 0, 0), 		glm::quat(1, 0, 0, 0),			"SM_Ball_01", 	"T_Block_04.png" );
		
		
		//0.036, 1, 0.792
		
		components["Ball_01"]->entityColor = glm::vec3(0.036, 1, 0.792);
	}
};




class Block : public Set
{
	//класс, описывающий облик простейшего блока арканоида
public:
	Block(glm::vec3 worldLoc = glm::vec3(0, 0, 0), glm::quat worldRot = glm::quat(1, 0, 0, 0), std::string blockTexture = "T_Default_01.png")
	{
		//printMessage("create field")
		worldLocation = worldLoc;		//назначим координаты
		worldRotation = worldRot;
		
		setType = "Block";
		
		addEntity( "Block_cell", glm::vec3(0.056251,-0.323372,0.217312), glm::quat(1.000000,0.000000,0.000000,0.000000), "SM_Block_01", blockTexture );  
		addEntity( "Block_cell.001", glm::vec3(-0.198276,0.101031,0.143956), glm::quat(1.000000,0.000000,0.000000,0.000000), "SM_Block_02", blockTexture );  
		addEntity( "Block_cell.002", glm::vec3(-0.096947,0.217471,0.846047), glm::quat(1.000000,0.000000,0.000000,0.000000), "SM_Block_03", blockTexture );  
		addEntity( "Block_cell.003", glm::vec3(-0.376408,0.066478,0.290749), glm::quat(1.000000,0.000000,0.000000,0.000000), "SM_Block_04", blockTexture );  
		addEntity( "Block_cell.004", glm::vec3(-0.055438,0.389080,0.737616), glm::quat(1.000000,0.000000,0.000000,0.000000), "SM_Block_05", blockTexture );  
		addEntity( "Block_cell.005", glm::vec3(0.307453,0.291156,0.360272), glm::quat(1.000000,0.000000,0.000000,0.000000), "SM_Block_06", blockTexture );  
		addEntity( "Block_cell.006", glm::vec3(-0.278690,-0.256923,0.728778), glm::quat(1.000000,0.000000,0.000000,0.000000), "SM_Block_07", blockTexture );  
		addEntity( "Block_cell.007", glm::vec3(0.204132,-0.366807,0.789733), glm::quat(1.000000,0.000000,0.000000,0.000000), "SM_Block_08", blockTexture );  
		addEntity( "Block_cell.008", glm::vec3(0.339808,-0.068332,0.799969), glm::quat(1.000000,0.000000,0.000000,0.000000), "SM_Block_09", blockTexture ); 
		
		glm::vec3 blockColor = glm::vec3(float(glm::linearRand(0,100)/100.0f),float(glm::linearRand(0,100)/100.0f),float(glm::linearRand(0,100)/100.0f));
		
		for (auto comp : components)
		{
			comp.second->entityColor = blockColor;
		}
		
		//элементарный блок имеет габариты 1x1x1, состоит из треугольников, так что добавим вектор из 12 матриц 3х3, хранящих координаты вершин ААВВ-коробки
		
		AABB = {
			glm::mat4(
			glm::vec4( -0.500000, -0.500000, 1.000000, 0),
			glm::vec4( -0.500000, 0.500000, 0.000000, 0),
			glm::vec4( -0.500000, -0.500000, 0.000000, 0),
			glm::vec4( -1.000000, 0.000000, 0.000000, 0) ),
			glm::mat4(
			glm::vec4( -0.500000, 0.500000, 1.000000, 0),
			glm::vec4( 0.500000, 0.500000, 0.000000, 0),
			glm::vec4( -0.500000, 0.500000, 0.000000, 0),
			glm::vec4( 0.000000, 1.000000, -0.000000, 0) ),
			glm::mat4(
			glm::vec4( 0.500000, 0.500000, 1.000000, 0),
			glm::vec4( 0.500000, -0.500000, 0.000000, 0),
			glm::vec4( 0.500000, 0.500000, 0.000000, 0),
			glm::vec4( 1.000000, 0.000000, -0.000000, 0) ),
			glm::mat4(
			glm::vec4( 0.500000, -0.500000, 1.000000, 0),
			glm::vec4( -0.500000, -0.500000, 0.000000, 0),
			glm::vec4( 0.500000, -0.500000, 0.000000, 0),
			glm::vec4( 0.000000, -1.000000, 0.000000, 0) ),
			glm::mat4(
			glm::vec4( 0.500000, 0.500000, 0.000000, 0),
			glm::vec4( -0.500000, -0.500000, 0.000000, 0),
			glm::vec4( -0.500000, 0.500000, 0.000000, 0),
			glm::vec4( 0.000000, 0.000000, -1.000000, 0) ),
			glm::mat4(
			glm::vec4( -0.500000, 0.500000, 1.000000, 0),
			glm::vec4( 0.500000, -0.500000, 1.000000, 0),
			glm::vec4( 0.500000, 0.500000, 1.000000, 0),
			glm::vec4( 0.000000, 0.000000, 1.000000, 0) ),
			glm::mat4(
			glm::vec4( -0.500000, -0.500000, 1.000000, 0),
			glm::vec4( -0.500000, 0.500000, 1.000000, 0),
			glm::vec4( -0.500000, 0.500000, 0.000000, 0),
			glm::vec4( -1.000000, 0.000000, 0.000000, 0) ),
			glm::mat4(
			glm::vec4( -0.500000, 0.500000, 1.000000, 0),
			glm::vec4( 0.500000, 0.500000, 1.000000, 0),
			glm::vec4( 0.500000, 0.500000, 0.000000, 0),
			glm::vec4( 0.000000, 1.000000, -0.000000, 0) ),
			glm::mat4(
			glm::vec4( 0.500000, 0.500000, 1.000000, 0),
			glm::vec4( 0.500000, -0.500000, 1.000000, 0),
			glm::vec4( 0.500000, -0.500000, 0.000000, 0),
			glm::vec4( 1.000000, 0.000000, 0.000000, 0) ),
			glm::mat4(
			glm::vec4( 0.500000, -0.500000, 1.000000, 0),
			glm::vec4( -0.500000, -0.500000, 1.000000, 0),
			glm::vec4( -0.500000, -0.500000, 0.000000, 0),
			glm::vec4( 0.000000, -1.000000, 0.000000, 0) ),
			glm::mat4(
			glm::vec4( 0.500000, 0.500000, 0.000000, 0),
			glm::vec4( 0.500000, -0.500000, 0.000000, 0),
			glm::vec4( -0.500000, -0.500000, 0.000000, 0),
			glm::vec4( 0.000000, 0.000000, -1.000000, 0) ),
			glm::mat4(
			glm::vec4( -0.500000, 0.500000, 1.000000, 0),
			glm::vec4( -0.500000, -0.500000, 1.000000, 0),
			glm::vec4( 0.500000, -0.500000, 1.000000, 0),
			glm::vec4( 0.000000, -0.000000, 1.000000, 0) ),

			};
		  
	}
	
	glm::vec3 blow1Start = glm::vec3(0.0563, -0.3234, 0.2173);
	glm::vec3 blow1End = glm::vec3(3.3431, -19.2185, -22.7475 );
	
	glm::vec3 blow2Start = glm::vec3(-0.1983, 0.101, 0.144);
	glm::vec3 blow2End = glm::vec3(-13.1963, 7.1971, -25.507 );
	
	glm::vec3 blow3Start = glm::vec3(-0.0969, 0.2175, 0.846);
	glm::vec3 blow3End = glm::vec3(-7.1798, 16.1057, 18.9173 );
	
	glm::vec3 blow4Start = glm::vec3(-0.3764, 0.0665, 0.2907);
	glm::vec3 blow4End = glm::vec3(-22.6472, 3.9998, -18.5939 );
	
	glm::vec3 blow5Start = glm::vec3(-0.0554, 0.3891, 0.7376);
	glm::vec3 blow5End = glm::vec3( -3.5805, 25.1292, 8.9353);
	
	glm::vec3 blow6Start = glm::vec3(0.3075, 0.2912, 0.3603);
	glm::vec3 blow6End = glm::vec3(18.4232, 17.4467, -14.4199 );
	
	glm::vec3 blow7Start = glm::vec3(-0.2787, -0.2569, 0.7288);
	glm::vec3 blow7End = glm::vec3(-18.6693, -17.2112, 8.8742 );
	
	glm::vec3 blow8Start = glm::vec3(0.2041, -0.3668, 0.7897);
	glm::vec3 blow8End = glm::vec3(11.9562, -21.4843, 10.646);
	
	glm::vec3 blow9Start = glm::vec3(0.3398, -0.0683, 0.8);
	glm::vec3 blow9End = glm::vec3( 22.4329, -4.511, 13.3077);
	
	#define BLOCK ((Block*)ptr)
	
	int timer = 0;
	int duration = 100;
	
	static bool blowBlock(void* ptr) //временнАя последовательность, которая описывает отыгрыш сцены закладки динамита в стену
	{
		//static int timer = 0;
		//static int duration = 1*1000/TICK ;
		
		//#define DURATION2 60
		
		//actors["Ball"]->worldLocation += forward*gameplayCarriageSpeed*float(TICK)/1000.0f;

		if (BLOCK->timer == 0) //в самом начале 
		{
			BLOCK->collision = false;
			BLOCK->duration = 0.75*1000/TICK ;
		}

		if (BLOCK->timer <= BLOCK->duration) //первые N кадров плавно подводим к точке старта
		{
			//std::cout << "moving" << std::endl;
			
			float coeff = float(BLOCK->timer) / float(BLOCK->duration);
			BLOCK->components["Block_cell"]->entityPosition 	= glm::mix(BLOCK->blow1Start,BLOCK->blow1End,coeff);
			BLOCK->components["Block_cell.001"]->entityPosition = glm::mix(BLOCK->blow2Start,BLOCK->blow2End,coeff);
			BLOCK->components["Block_cell.002"]->entityPosition = glm::mix(BLOCK->blow3Start,BLOCK->blow3End,coeff);
			BLOCK->components["Block_cell.003"]->entityPosition = glm::mix(BLOCK->blow4Start,BLOCK->blow4End,coeff);
			BLOCK->components["Block_cell.004"]->entityPosition = glm::mix(BLOCK->blow5Start,BLOCK->blow5End,coeff);
			BLOCK->components["Block_cell.005"]->entityPosition = glm::mix(BLOCK->blow6Start,BLOCK->blow6End,coeff);
			BLOCK->components["Block_cell.006"]->entityPosition = glm::mix(BLOCK->blow7Start,BLOCK->blow7End,coeff);
			BLOCK->components["Block_cell.007"]->entityPosition = glm::mix(BLOCK->blow8Start,BLOCK->blow8End,coeff);
			BLOCK->components["Block_cell.008"]->entityPosition = glm::mix(BLOCK->blow9Start,BLOCK->blow9End,coeff);
		}
	
		
		if (BLOCK->timer == BLOCK->duration)
		{
			//if(BLOCK->setType == "Block") {}
			BLOCK->visible = false;
			BLOCK->timer = 0; 	return true;
		}
		else
		{
			BLOCK->timer++;	return false;
		}
	}
	
	void update() override
	{
		
	}
};



class Camera : public Set
{
public:
	
	Camera()
	{
		//actors["Panel"] = new Entity ();
		
		setType = "Camera";
		
		//worldLocation = glm::vec3(17,8.3,6.7);
		//worldRotation = glm::quat(0.646,0.338,0.318,0.606);
	}

	
	glm::vec3 forwardVector 	= glm::vec3(0,0,-1);
	
	float cameraFOV = 80.0f; //угол обзора камеры
	
	glm::mat2x3 	cameraVectorsForwardAndRight = glm::mat2x3(glm::vec3(0, 0, -1), 	//перед камеры
												glm::vec3(1, 0, 0));	//правый вектор
	
	glm::vec3 cameraUpVec = glm::vec3(0, 0, 1);	//вектор верха камеры по игровому. В блендере изначально  (0,1,0)
	
	glm::mat2x3 	cameraDefVectorsForwardAndRight = cameraVectorsForwardAndRight;//исходные вектора камеры
	
	glm::ivec2 windowResolution		= glm::ivec2(1366, 768);
	//взгляд камеры в своем локальном пространстве совпадает с осью -Z
	
	void init() override
	{
		//#define dvsvsdvds 2
		//~ addEntity("Panel1", 	glm::vec3(2, 0, 0), 		glm::quat(1, 0, 0, 0),			"SM_Ball_01", 	"T_Block_01.png" );
		//~ addEntity("Panel2", 	glm::vec3(0, 2, 0), 		glm::quat(1, 0, 0, 0),			"SM_Ball_01", 	"T_Block_02.png" );
		
		//~ addEntity("Panel3", 	glm::vec3(-2, 0, 0), 		glm::quat(1, 0, 0, 0),			"SM_Ball_01", 	"T_Block_03.png" );
		//~ addEntity("Panel4", 	glm::vec3(0, -2, 0), 		glm::quat(1, 0, 0, 0),			"SM_Ball_01", 	"T_Block_04.png" );
		
		
		//~ addEntity("Panel11", 	glm::vec3(2, 0, 2), 		glm::quat(1, 0, 0, 0),			"SM_Ball_01", 	"T_Block_05.png" );
		//~ addEntity("Panel21", 	glm::vec3(0, 2, 2), 		glm::quat(1, 0, 0, 0),			"SM_Ball_01", 	"T_Block_06.png" );
		
		//~ addEntity("Panel31", 	glm::vec3(-2, 0, 2), 		glm::quat(1, 0, 0, 0),			"SM_Ball_01", 	"T_Block_07.png" );
		//~ addEntity("Panel41", 	glm::vec3(0, -2, 2), 		glm::quat(1, 0, 0, 0),			"SM_Ball_01", 	"T_Block_08.png" );
		
		//слева синий 3, справа красный 1, сверху зеленый 2
		
		//~ addEntity("Heart_1", 	glm::vec3(-5, 2, -4), 		glm::quat(1, 0, 0, 0),			"SM_Banner_1024", 	"heart.png" );
		//~ addEntity("Heart_2", 	glm::vec3(-4, 2, -4), 		glm::quat(1, 0, 0, 0),			"SM_Banner_1024", 	"heart.png" );
		//~ addEntity("Heart_3", 	glm::vec3(-3, 2, -4), 		glm::quat(1, 0, 0, 0),			"SM_Banner_1024", 	"heart.png" );
		
		addEntity("Heart_1", 	glm::vec3(-1, 3.5, -5), 		glm::quat(1, 0, 0, 0),			"SM_Banner_1024", 	"heart.png" );
		addEntity("Heart_2", 	glm::vec3(0,  3.5, -5), 		glm::quat(1, 0, 0, 0),			"SM_Banner_1024", 	"heart.png" );
		addEntity("Heart_3", 	glm::vec3(1,  3.5, -5), 		glm::quat(1, 0, 0, 0),			"SM_Banner_1024", 	"heart.png" );
		
		addEntity("MainMenu", 	glm::vec3(0, 0, -0.5), 		glm::quat(1, 0, 0, 0),			"SM_Banner_1024", 	"MainMenu.png" );
		
		addEntity("Gameover", 	glm::vec3(0, 0, -1), 		glm::quat(1, 0, 0, 0),			"SM_Banner_1024", 	"gameover.png" );
		
		addEntity("Failure", 	glm::vec3(0, 0, -1), 		glm::quat(1, 0, 0, 0),			"SM_Banner_1024", 	"failure.png" );
		
		addEntity("Victory", 	glm::vec3(0, 0, -1), 		glm::quat(1, 0, 0, 0),			"SM_Banner_1024", 	"winner.png" );
		
		components["Heart_1"]->visible = false;
		components["Heart_2"]->visible = false;
		components["Heart_3"]->visible = false;
		
		components["Gameover"]->visible = false;
		components["Failure"]->visible = false;
		
		components["Victory"]->visible = false;
		
		addEntity("Hint", 	glm::vec3(0, 0, -1), 		glm::quat(1, 0, 0, 0),			"SM_Banner_1024", 	"hint.png" );
		components["Hint"]->visible = false;
		
		
		colorable = 0;
		
		
	}
	
	
	void update() override
	{
		glm::mat3 m = mat3_cast(worldRotation);//glm::mat3 m = mat3_cast(cameraRotation);	//матрица ориентации камеры из кватерниона

		cameraVectorsForwardAndRight = m * cameraDefVectorsForwardAndRight;
		
		//~ printVec2(windowResolution)
		//~ printVec3(components["Heart_1"]->entityPosition)
		//~ printVec3(components["Heart_2"]->entityPosition)
		
		//~ float BC = 2*(1.0f-glm::cos(glm::radians(cameraFOV)))*(4.0f) / glm::sin(glm::radians(80.0f));
		
		//~ printVariable(BC)
		//~ if(setType == "Camera")
		//~ {
			//printMessage("Camera")
			glm::vec3 POV = worldLocation;
			glm::vec3 DOV = POV + cameraVectorsForwardAndRight[0];
			glm::vec3 UP = cameraUpVec;	
			
			
			
			GLfloat ratio = float(windowResolution.x) / float(windowResolution.y); //windowResolution.x / windowResolution.y;    //ratio - соотношение
			
			ProjViewMatrix = glm::perspective(glm::radians(cameraFOV), ratio, 0.01f, 7000.0f);
			//ProjViewMatrix = glm::ortho(-1.0f, 1.0f, -1.0f * ratio, 1.0f*ratio, 0.01f, 7000.0f );
			//~ ProjViewMatrix = glm::ortho(0.0f, 1.0f*float(windowResolution.x), 0.0f, 1.0f*float(windowResolution.y), 0.1f, 100.0f );
			
			//~ ProjViewMatrix = glm::ortho(-0.5f*float(windowResolution.x), 0.5f*float(windowResolution.x), -0.5f*float(windowResolution.y), 0.5f*float(windowResolution.y), 0.1f, 100.0f );
			
			ProjViewMatrix = ProjViewMatrix*glm::lookAt(POV, //позиция точки наблюдения
														DOV, //направление наблюдения
														UP); //направление вверх;
														
														
		//~ glm::vec3 POV = Cam.worldLocation;
		//~ glm::vec3 DOV = POV + Cam.cameraVectorsForwardAndRight[0];
		//~ glm::vec3 UP = Cam.cameraUpVec;		
		//~ ProjViewMatrix = configureProjMatrix(Cam.cameraFOV)*configureViewMatrix(POV, DOV, UP);//;// * ; glm::mat4(1.0);//
			
		//~ }
		//~ components["Heart_1"]->entityPosition.x = -(BC)*0.5f/2.0f;
		
		//~ printVec3(worldLocation)
		//~ printQuat(worldRotation)
		
		//~ printVec3(cameraVectorsForwardAndRight[0])
		
		//~ printVec3(components["Panel"]->entityPosition)
		
	}
	
	
	#define CAM ((Camera*)ptr)
	
	int timer = 0;
	int duration = 100;
	
	static bool showHint(void* ptr) //временнАя последовательность, которая описывает отыгрыш сцены закладки динамита в стену
	{
		if (CAM->timer == 0) //в самом начале 
		{
			CAM->components["Hint"]->visible = true;
			CAM->duration = 2*1000/TICK ;
		}
		
		if (CAM->timer == CAM->duration)
		{
			CAM->components["Hint"]->visible = false;
			CAM->timer = 0; 	return true;
		}
		else
		{
			CAM->timer++;	return false;
		}
	}
};

class Arkanoid
{
	// игровой уровень - здесь вся логика арканоида
	
private:
	//параметры камеры
	Camera Cam;
	
	
	//~ glm::ivec2 windowResolution		= glm::ivec2(1366, 768);
	
	
	//gameplay
	
	glm::vec3 forward = glm::vec3(0,1,0);//getRandomForwardVector(); //впереднаправленный вектор мяча по умолчанию 
	
	
	float defaultGameplaySpeed = 1.0;
	float gameplaySpeedUp = defaultGameplaySpeed; //ускоритель геймплея
	float gameplayCarriageSpeed = 15.0f; //метров в секунду. Параметр регулируется жестко в угоду баланса
	
	float ballSpeed = 1;	//метров в секунду. Параметр регулируется жестко в угоду баланса
	
	float ballDelta = 0.1f;//смещение мяча по оси впередсмотрящего вектора forward за один кадр, нужно для корректного просчета коллизий
	
	bool gameplayProcess = false;
	
	//игровые объекты
	std::map <std::string, Set*> actors;
	
	std::map <std::string, Set*> level_1;
	std::map <std::string, Set*> level_2;
	std::map <std::string, Set*> level_3;
	
	GLFWwindow* engineWindow;
	
	int lives = 3;	//количество попыток по умолчанию
	
	//переменные, отвечающие за логику игры
	int state = 0; // 0 - menu, 1 - in game, 2 - pause
	
	#define GAME ((Arkanoid*)ptr)
		
	glm::mat4 ProjViewMatrix = glm::mat4(1.0);
	
	float menuRotationAngle = 0.0f;
	
	bool enterPressed = false;
	bool spacePressed = false;
	
	bool bNextLevel = false;
	
	bool carriageControl = false;
	
	int blocksCount = 1;
	
	int currentLevel = 2;
		
	bool bChangeLevel = false;
	
	bool levelSelected = false;
	
	bool hasAutopilotBonus = false;
	
	//bool autoPilot = false;
	
	int fieldWatchDog = 0; //сторожевой таймер для отслеживания, сколько касаний было НЕ от блоков
	
	//bool haveBonus = false;
	
	void destroySetsInRadius()
	{
		if(currentLevel == 0)
		{
			for(auto act : level_1)
			{
				if( glm::length(act.second->worldLocation - actors["Ball"]->worldLocation) < 20.0f)
				{
					Block* blk = dynamic_cast<Block*>(act.second);
		
					if(blk!=nullptr)
					{
						Flow.CallSequence( {"blowBlock", blk->blowBlock, blk} );
					}
				}
			}
		}
		
		if(currentLevel == 1)
		{
			for(auto act : level_2)
			{
				if( glm::length(act.second->worldLocation - actors["Ball"]->worldLocation) < 20.0f)
				{
					Block* blk = dynamic_cast<Block*>(act.second);
		
					if(blk!=nullptr)
					{
						Flow.CallSequence( {"blowBlock", blk->blowBlock, blk} );
					}
				}
			}
		}
		if(currentLevel == 2)
		{
			for(auto act : level_3)
			{
				if( glm::length(act.second->worldLocation - actors["Ball"]->worldLocation) < 20.0f)
				{
					Block* blk = dynamic_cast<Block*>(act.second);
		
					if(blk!=nullptr)
					{
						Flow.CallSequence( {"blowBlock", blk->blowBlock, blk} );
					}
				}
			}
		}
	}
	
	void loadEnvironment()
	{
		actors["Field"] = new Field( glm::vec3(0,0,0), glm::quat(1,0,0,0) );	//загрузим поле
		actors["Carriage"] = new Carriage( glm::vec3(0,0,0), glm::quat(1,0,0,0) );	//загрузим каретку
		actors["Ball"] = new Ball( glm::vec3(0,1,0.5), glm::quat(1,0,0,0) );
	}
	
	void reloadLevel() // функция заново инициализирует конкретный уровень
	{
		//std::cout << "Flag 1\n";
		if(!level_1.empty())
		{	for(auto act: level_1)	{	delete act.second;	}
			level_1.clear(); }
		
		if(!level_2.empty())
		{	for(auto act: level_2)	{	delete act.second;	}
			level_2.clear();	}
		
		if(!level_3.empty())
		{	for(auto act: level_3)	{	delete act.second;	}
			level_3.clear(); }
			
			
		currentLevel = currentLevel < 2 ? currentLevel+1 : 0;
		
		printVariable(currentLevel)
		
		if(currentLevel == 0)
		{
			// level 1 just blocks
			{
				level_1["Block.563"] = new Block( glm::vec3(4.000000,23.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.564"] = new Block( glm::vec3(5.000000,23.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.565"] = new Block( glm::vec3(6.000000,23.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				
				level_1["Block.566"] = new Block( glm::vec3(7.000000,23.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.567"] = new Block( glm::vec3(8.000000,23.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.568"] = new Block( glm::vec3(9.000000,23.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.569"] = new Block( glm::vec3(10.000000,23.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.570"] = new Block( glm::vec3(11.000000,23.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.571"] = new Block( glm::vec3(12.000000,23.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.572"] = new Block( glm::vec3(13.000000,23.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.573"] = new Block( glm::vec3(14.000000,23.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_1["Block.574"] = new Block( glm::vec3(15.000000,23.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_1["Block.575"] = new Block( glm::vec3(16.000000,23.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.576"] = new Block( glm::vec3(17.000000,23.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.577"] = new Block( glm::vec3(18.000000,23.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.578"] = new Block( glm::vec3(19.000000,23.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.579"] = new Block( glm::vec3(20.000000,23.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.580"] = new Block( glm::vec3(21.000000,23.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.581"] = new Block( glm::vec3(22.000000,23.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.582"] = new Block( glm::vec3(23.000000,23.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.583"] = new Block( glm::vec3(-23.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.584"] = new Block( glm::vec3(-22.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.585"] = new Block( glm::vec3(-21.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.586"] = new Block( glm::vec3(-20.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.587"] = new Block( glm::vec3(-19.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.588"] = new Block( glm::vec3(-18.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_1["Block.589"] = new Block( glm::vec3(-17.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.590"] = new Block( glm::vec3(-16.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.591"] = new Block( glm::vec3(-15.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.592"] = new Block( glm::vec3(-14.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.593"] = new Block( glm::vec3(-13.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.594"] = new Block( glm::vec3(-12.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.595"] = new Block( glm::vec3(-11.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.596"] = new Block( glm::vec3(-10.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.597"] = new Block( glm::vec3(-9.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.598"] = new Block( glm::vec3(-8.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.599"] = new Block( glm::vec3(-7.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.600"] = new Block( glm::vec3(-6.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.601"] = new Block( glm::vec3(-5.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.602"] = new Block( glm::vec3(-4.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.603"] = new Block( glm::vec3(-3.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.604"] = new Block( glm::vec3(-2.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.605"] = new Block( glm::vec3(-1.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.606"] = new Block( glm::vec3(0.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.607"] = new Block( glm::vec3(1.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.608"] = new Block( glm::vec3(2.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.609"] = new Block( glm::vec3(3.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_1["Block.610"] = new Block( glm::vec3(4.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.611"] = new Block( glm::vec3(5.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_1["Block.612"] = new Block( glm::vec3(6.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.613"] = new Block( glm::vec3(7.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.614"] = new Block( glm::vec3(8.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.615"] = new Block( glm::vec3(9.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.616"] = new Block( glm::vec3(10.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.617"] = new Block( glm::vec3(11.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_1["Block.618"] = new Block( glm::vec3(12.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.619"] = new Block( glm::vec3(13.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.620"] = new Block( glm::vec3(14.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.621"] = new Block( glm::vec3(15.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.622"] = new Block( glm::vec3(16.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.623"] = new Block( glm::vec3(17.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.624"] = new Block( glm::vec3(18.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.625"] = new Block( glm::vec3(19.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.626"] = new Block( glm::vec3(20.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.627"] = new Block( glm::vec3(21.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.628"] = new Block( glm::vec3(22.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.629"] = new Block( glm::vec3(23.000000,24.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.630"] = new Block( glm::vec3(-23.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.631"] = new Block( glm::vec3(-22.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.632"] = new Block( glm::vec3(-21.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.633"] = new Block( glm::vec3(-20.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.634"] = new Block( glm::vec3(-19.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.635"] = new Block( glm::vec3(-18.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.636"] = new Block( glm::vec3(-17.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.637"] = new Block( glm::vec3(-16.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.638"] = new Block( glm::vec3(-15.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.639"] = new Block( glm::vec3(-14.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_1["Block.640"] = new Block( glm::vec3(-13.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_1["Block.641"] = new Block( glm::vec3(-12.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.642"] = new Block( glm::vec3(-11.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.643"] = new Block( glm::vec3(-10.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.644"] = new Block( glm::vec3(-9.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.645"] = new Block( glm::vec3(-8.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.646"] = new Block( glm::vec3(-7.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.647"] = new Block( glm::vec3(-6.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.648"] = new Block( glm::vec3(-5.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.649"] = new Block( glm::vec3(-4.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.650"] = new Block( glm::vec3(-3.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.651"] = new Block( glm::vec3(-2.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.652"] = new Block( glm::vec3(-1.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.653"] = new Block( glm::vec3(0.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.654"] = new Block( glm::vec3(1.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.655"] = new Block( glm::vec3(2.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.656"] = new Block( glm::vec3(3.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.657"] = new Block( glm::vec3(4.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.658"] = new Block( glm::vec3(5.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.659"] = new Block( glm::vec3(6.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.660"] = new Block( glm::vec3(7.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.661"] = new Block( glm::vec3(8.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.662"] = new Block( glm::vec3(9.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.663"] = new Block( glm::vec3(10.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.664"] = new Block( glm::vec3(11.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.665"] = new Block( glm::vec3(12.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_1["Block.666"] = new Block( glm::vec3(13.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.667"] = new Block( glm::vec3(14.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_1["Block.668"] = new Block( glm::vec3(15.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.669"] = new Block( glm::vec3(16.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.670"] = new Block( glm::vec3(17.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.671"] = new Block( glm::vec3(18.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.672"] = new Block( glm::vec3(19.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.673"] = new Block( glm::vec3(20.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_1["Block.674"] = new Block( glm::vec3(21.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.675"] = new Block( glm::vec3(22.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.676"] = new Block( glm::vec3(23.000000,25.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.677"] = new Block( glm::vec3(-23.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.678"] = new Block( glm::vec3(-22.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.679"] = new Block( glm::vec3(-21.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.680"] = new Block( glm::vec3(-20.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.681"] = new Block( glm::vec3(-19.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_1["Block.682"] = new Block( glm::vec3(-18.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_1["Block.683"] = new Block( glm::vec3(-17.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.684"] = new Block( glm::vec3(-16.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.685"] = new Block( glm::vec3(-15.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.686"] = new Block( glm::vec3(-14.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.687"] = new Block( glm::vec3(-13.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.688"] = new Block( glm::vec3(-12.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_1["Block.689"] = new Block( glm::vec3(-11.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.690"] = new Block( glm::vec3(-10.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_1["Block.691"] = new Block( glm::vec3(-9.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.692"] = new Block( glm::vec3(-8.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.693"] = new Block( glm::vec3(-7.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.694"] = new Block( glm::vec3(-6.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.695"] = new Block( glm::vec3(-5.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.696"] = new Block( glm::vec3(-4.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.697"] = new Block( glm::vec3(-3.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.698"] = new Block( glm::vec3(-2.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_1["Block.699"] = new Block( glm::vec3(-1.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.700"] = new Block( glm::vec3(0.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.701"] = new Block( glm::vec3(1.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_1["Block.702"] = new Block( glm::vec3(2.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.703"] = new Block( glm::vec3(3.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.704"] = new Block( glm::vec3(4.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.705"] = new Block( glm::vec3(5.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.706"] = new Block( glm::vec3(6.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.707"] = new Block( glm::vec3(7.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.708"] = new Block( glm::vec3(8.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.709"] = new Block( glm::vec3(9.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_1["Block.710"] = new Block( glm::vec3(10.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.711"] = new Block( glm::vec3(11.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.712"] = new Block( glm::vec3(12.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_1["Block.713"] = new Block( glm::vec3(13.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.714"] = new Block( glm::vec3(14.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.715"] = new Block( glm::vec3(15.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.716"] = new Block( glm::vec3(16.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.717"] = new Block( glm::vec3(17.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.718"] = new Block( glm::vec3(18.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.719"] = new Block( glm::vec3(19.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.720"] = new Block( glm::vec3(20.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.721"] = new Block( glm::vec3(21.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.722"] = new Block( glm::vec3(22.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.723"] = new Block( glm::vec3(23.000000,26.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.724"] = new Block( glm::vec3(-23.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.725"] = new Block( glm::vec3(-22.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.726"] = new Block( glm::vec3(-21.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.727"] = new Block( glm::vec3(-20.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.728"] = new Block( glm::vec3(-19.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.729"] = new Block( glm::vec3(-18.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.730"] = new Block( glm::vec3(-17.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.731"] = new Block( glm::vec3(-16.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.732"] = new Block( glm::vec3(-15.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.733"] = new Block( glm::vec3(-14.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_1["Block.734"] = new Block( glm::vec3(-13.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.735"] = new Block( glm::vec3(-12.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.736"] = new Block( glm::vec3(-11.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.737"] = new Block( glm::vec3(-10.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.738"] = new Block( glm::vec3(-9.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_1["Block.739"] = new Block( glm::vec3(-8.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.740"] = new Block( glm::vec3(-7.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.741"] = new Block( glm::vec3(-6.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_1["Block.742"] = new Block( glm::vec3(-5.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.743"] = new Block( glm::vec3(-4.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.744"] = new Block( glm::vec3(-3.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.745"] = new Block( glm::vec3(-2.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.746"] = new Block( glm::vec3(-1.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.747"] = new Block( glm::vec3(0.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.748"] = new Block( glm::vec3(1.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.749"] = new Block( glm::vec3(2.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.750"] = new Block( glm::vec3(3.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.751"] = new Block( glm::vec3(4.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.752"] = new Block( glm::vec3(5.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.753"] = new Block( glm::vec3(6.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.754"] = new Block( glm::vec3(7.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.755"] = new Block( glm::vec3(8.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.756"] = new Block( glm::vec3(9.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.757"] = new Block( glm::vec3(10.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.758"] = new Block( glm::vec3(11.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.759"] = new Block( glm::vec3(12.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.760"] = new Block( glm::vec3(13.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.761"] = new Block( glm::vec3(14.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.762"] = new Block( glm::vec3(15.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.763"] = new Block( glm::vec3(16.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.764"] = new Block( glm::vec3(17.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.765"] = new Block( glm::vec3(18.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.766"] = new Block( glm::vec3(19.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.767"] = new Block( glm::vec3(20.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.768"] = new Block( glm::vec3(21.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.769"] = new Block( glm::vec3(22.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.770"] = new Block( glm::vec3(23.000000,27.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.771"] = new Block( glm::vec3(-23.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.772"] = new Block( glm::vec3(-22.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.773"] = new Block( glm::vec3(-21.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.774"] = new Block( glm::vec3(-20.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.775"] = new Block( glm::vec3(-19.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.776"] = new Block( glm::vec3(-18.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.777"] = new Block( glm::vec3(-17.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.778"] = new Block( glm::vec3(-16.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_1["Block.779"] = new Block( glm::vec3(-15.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.780"] = new Block( glm::vec3(-14.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.781"] = new Block( glm::vec3(-13.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.782"] = new Block( glm::vec3(-12.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.783"] = new Block( glm::vec3(-11.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.784"] = new Block( glm::vec3(-10.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.785"] = new Block( glm::vec3(-9.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.786"] = new Block( glm::vec3(-8.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.787"] = new Block( glm::vec3(-7.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.788"] = new Block( glm::vec3(-6.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.789"] = new Block( glm::vec3(-5.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.790"] = new Block( glm::vec3(-4.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_1["Block.791"] = new Block( glm::vec3(-3.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.792"] = new Block( glm::vec3(-2.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.793"] = new Block( glm::vec3(-1.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.794"] = new Block( glm::vec3(0.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.795"] = new Block( glm::vec3(1.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.796"] = new Block( glm::vec3(2.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.797"] = new Block( glm::vec3(3.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_1["Block.798"] = new Block( glm::vec3(4.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.799"] = new Block( glm::vec3(5.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.800"] = new Block( glm::vec3(6.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.801"] = new Block( glm::vec3(7.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.802"] = new Block( glm::vec3(8.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.803"] = new Block( glm::vec3(9.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_1["Block.804"] = new Block( glm::vec3(10.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.805"] = new Block( glm::vec3(11.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.806"] = new Block( glm::vec3(12.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_1["Block.807"] = new Block( glm::vec3(13.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.808"] = new Block( glm::vec3(14.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.809"] = new Block( glm::vec3(15.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.810"] = new Block( glm::vec3(16.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.811"] = new Block( glm::vec3(17.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_1["Block.812"] = new Block( glm::vec3(18.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_1["Block.813"] = new Block( glm::vec3(19.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_1["Block.814"] = new Block( glm::vec3(20.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.815"] = new Block( glm::vec3(21.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_1["Block.816"] = new Block( glm::vec3(22.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_1["Block.817"] = new Block( glm::vec3(23.000000,28.000000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
			}
		}
		
		if(currentLevel == 1)
		{
			// level 2 SINEUS 2024 INDOOSTRIALNIY
			{
							
				level_2["Block.002"] = new Block( glm::vec3(-23.410103,17.945850,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_2["Block.123"] = new Block( glm::vec3(-23.411974,18.992237,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_2["Block.124"] = new Block( glm::vec3(-23.403242,20.029839,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_2["Block.125"] = new Block( glm::vec3(-21.780645,17.971088,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_2["Block.126"] = new Block( glm::vec3(-21.752222,18.976204,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.127"] = new Block( glm::vec3(-21.769682,19.934017,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_2["Block.128"] = new Block( glm::vec3(-20.768721,19.877499,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_2["Block.129"] = new Block( glm::vec3(-18.875387,17.909649,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_2["Block.130"] = new Block( glm::vec3(-18.886681,18.900578,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_2["Block.131"] = new Block( glm::vec3(-18.876184,19.916351,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_2["Block.132"] = new Block( glm::vec3(-17.258524,17.788395,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_2["Block.133"] = new Block( glm::vec3(-17.247923,18.813972,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_2["Block.134"] = new Block( glm::vec3(-17.266838,19.828945,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_2["Block.135"] = new Block( glm::vec3(-17.278687,20.843922,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.136"] = new Block( glm::vec3(-16.202290,20.695095,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_2["Block.137"] = new Block( glm::vec3(-16.198652,18.045933,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_2["Block.138"] = new Block( glm::vec3(-15.150629,18.753796,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_2["Block.139"] = new Block( glm::vec3(-15.167257,19.812515,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_2["Block.140"] = new Block( glm::vec3(-23.408232,21.063107,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_2["Block.141"] = new Block( glm::vec3(-21.762094,20.931637,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_2["Block.142"] = new Block( glm::vec3(-18.891462,20.956161,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_2["Block.143"] = new Block( glm::vec3(-19.840683,18.883381,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_2["Block.145"] = new Block( glm::vec3(-13.711340,18.761044,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_2["Block.146"] = new Block( glm::vec3(-13.693086,19.788651,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_2["Block.148"] = new Block( glm::vec3(-12.678698,20.789402,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_2["Block.149"] = new Block( glm::vec3(-12.688773,17.827011,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_2["Block.150"] = new Block( glm::vec3(-11.697044,18.742371,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_2["Block.151"] = new Block( glm::vec3(-11.714034,19.796406,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.144"] = new Block( glm::vec3(-10.128521,18.680229,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_2["Block.147"] = new Block( glm::vec3(-10.110267,19.707832,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.152"] = new Block( glm::vec3(-9.095879,20.708584,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_2["Block.153"] = new Block( glm::vec3(-9.105954,17.746193,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_2["Block.154"] = new Block( glm::vec3(-8.114225,18.661552,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_2["Block.155"] = new Block( glm::vec3(-8.131215,19.715591,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_2["Block.157"] = new Block( glm::vec3(-5.715291,20.806416,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_2["Block.159"] = new Block( glm::vec3(-6.616878,19.761059,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_2["Block.160"] = new Block( glm::vec3(-5.639075,18.848213,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_2["Block.161"] = new Block( glm::vec3(-6.594359,17.886002,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				
				level_2["Block.156"] = new Block( glm::vec3(-2.937622,20.736374,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.158"] = new Block( glm::vec3(-2.903965,19.730110,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_2["Block.162"] = new Block( glm::vec3(-2.927566,18.690960,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				
				level_2["Block.163"] = new Block( glm::vec3(-2.926556,17.674618,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_2["Block.164"] = new Block( glm::vec3(-3.967593,20.713818,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_2["Block.165"] = new Block( glm::vec3(-1.892616,20.728855,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.166"] = new Block( glm::vec3(-0.417852,17.547947,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_2["Block.167"] = new Block( glm::vec3(-0.407253,18.573521,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_2["Block.168"] = new Block( glm::vec3(-0.426168,19.588493,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_2["Block.169"] = new Block( glm::vec3(-0.438014,20.603470,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_2["Block.170"] = new Block( glm::vec3(0.595076,21.122246,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_2["Block.171"] = new Block( glm::vec3(1.253688,18.619236,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.172"] = new Block( glm::vec3(0.618272,19.612183,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_2["Block.173"] = new Block( glm::vec3(1.660784,20.499489,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.174"] = new Block( glm::vec3(1.843703,17.585354,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_2["Block.175"] = new Block( glm::vec3(3.886794,20.669025,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.176"] = new Block( glm::vec3(3.920451,19.662766,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_2["Block.177"] = new Block( glm::vec3(3.896851,18.623615,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_2["Block.178"] = new Block( glm::vec3(3.897860,17.607273,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_2["Block.180"] = new Block( glm::vec3(5.946639,19.665710,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_2["Block.181"] = new Block( glm::vec3(5.674045,18.604908,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_2["Block.182"] = new Block( glm::vec3(5.675052,17.588566,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_2["Block.184"] = new Block( glm::vec3(7.623626,19.659821,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.185"] = new Block( glm::vec3(7.881503,18.642323,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_2["Block.186"] = new Block( glm::vec3(7.882510,17.625980,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_2["Block.187"] = new Block( glm::vec3(6.749007,20.687733,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_2["Block.179"] = new Block( glm::vec3(6.803138,18.619972,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.183"] = new Block( glm::vec3(9.576203,20.539722,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_2["Block.188"] = new Block( glm::vec3(9.609860,19.533459,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_2["Block.189"] = new Block( glm::vec3(9.586261,18.494308,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_2["Block.190"] = new Block( glm::vec3(9.587270,17.477966,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_2["Block.191"] = new Block( glm::vec3(10.656240,17.432194,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.192"] = new Block( glm::vec3(11.725209,17.414814,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.193"] = new Block( glm::vec3(13.243361,17.580070,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_2["Block.194"] = new Block( glm::vec3(13.271784,18.585186,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_2["Block.195"] = new Block( glm::vec3(13.254324,19.542999,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_2["Block.196"] = new Block( glm::vec3(14.255285,19.486481,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.197"] = new Block( glm::vec3(16.148619,17.518631,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_2["Block.198"] = new Block( glm::vec3(16.137323,18.509560,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_2["Block.199"] = new Block( glm::vec3(16.147821,19.525333,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_2["Block.200"] = new Block( glm::vec3(13.261911,20.540619,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.201"] = new Block( glm::vec3(16.132544,20.565144,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_2["Block.202"] = new Block( glm::vec3(15.183321,18.492363,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_2["Block.203"] = new Block( glm::vec3(18.019285,20.389729,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_2["Block.204"] = new Block( glm::vec3(18.052942,19.383469,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_2["Block.205"] = new Block( glm::vec3(18.029345,18.344318,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.206"] = new Block( glm::vec3(18.030352,17.327976,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_2["Block.207"] = new Block( glm::vec3(23.280397,20.327370,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_2["Block.208"] = new Block( glm::vec3(22.628119,19.180805,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_2["Block.209"] = new Block( glm::vec3(21.636110,18.299419,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_2["Block.210"] = new Block( glm::vec3(20.742907,17.296795,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_2["Block.211"] = new Block( glm::vec3(21.052355,19.300343,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.212"] = new Block( glm::vec3(20.553495,20.344833,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_2["Block.001"] = new Block( glm::vec3(-15.845139,26.988815,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_2["Block.213"] = new Block( glm::vec3(-16.746725,25.943459,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_2["Block.214"] = new Block( glm::vec3(-15.768923,25.030613,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_2["Block.215"] = new Block( glm::vec3(-16.724207,24.068401,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_2["Block.216"] = new Block( glm::vec3(-13.773686,23.808971,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_2["Block.217"] = new Block( glm::vec3(-13.775558,24.855358,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_2["Block.218"] = new Block( glm::vec3(-13.766826,25.892960,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_2["Block.219"] = new Block( glm::vec3(-12.144229,23.834209,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_2["Block.220"] = new Block( glm::vec3(-12.115806,24.839325,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_2["Block.221"] = new Block( glm::vec3(-12.133265,25.797138,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_2["Block.222"] = new Block( glm::vec3(-11.132304,25.740620,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_2["Block.223"] = new Block( glm::vec3(-9.238971,23.772770,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_2["Block.224"] = new Block( glm::vec3(-9.250264,24.763699,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_2["Block.225"] = new Block( glm::vec3(-9.239768,25.779472,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_2["Block.226"] = new Block( glm::vec3(-13.771815,26.926228,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_2["Block.227"] = new Block( glm::vec3(-12.125678,26.794758,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_2["Block.228"] = new Block( glm::vec3(-9.255046,26.819283,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_2["Block.229"] = new Block( glm::vec3(-10.204267,24.746502,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_2["Block.230"] = new Block( glm::vec3(-6.836628,23.721893,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_2["Block.231"] = new Block( glm::vec3(-6.838499,24.768284,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_2["Block.232"] = new Block( glm::vec3(-6.829767,25.805885,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_2["Block.233"] = new Block( glm::vec3(-6.834757,26.839149,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.234"] = new Block( glm::vec3(-5.755777,26.829430,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_2["Block.235"] = new Block( glm::vec3(-5.794660,25.176941,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.236"] = new Block( glm::vec3(-5.814100,23.670258,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_2["Block.238"] = new Block( glm::vec3(-3.964521,24.766762,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_2["Block.239"] = new Block( glm::vec3(-3.981981,25.724575,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_2["Block.240"] = new Block( glm::vec3(-3.269369,23.617134,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_2["Block.242"] = new Block( glm::vec3(-1.300544,24.691135,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.243"] = new Block( glm::vec3(-1.290048,25.706909,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_2["Block.244"] = new Block( glm::vec3(-3.974393,26.722195,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_2["Block.245"] = new Block( glm::vec3(-1.305326,26.746719,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_2["Block.246"] = new Block( glm::vec3(-2.198556,23.654915,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_2["Block.237"] = new Block( glm::vec3(1.408464,26.738037,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_2["Block.241"] = new Block( glm::vec3(0.506878,25.692680,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_2["Block.247"] = new Block( glm::vec3(1.484680,24.779835,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_2["Block.248"] = new Block( glm::vec3(0.529396,23.817623,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_2["Block.249"] = new Block( glm::vec3(10.644346,24.907909,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_2["Block.250"] = new Block( glm::vec3(10.662601,25.935513,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_2["Block.251"] = new Block( glm::vec3(11.676989,26.936264,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_2["Block.252"] = new Block( glm::vec3(11.666913,23.973873,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_2["Block.253"] = new Block( glm::vec3(12.658642,24.889233,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_2["Block.254"] = new Block( glm::vec3(12.641653,25.943272,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.255"] = new Block( glm::vec3(10.662165,26.994587,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_2["Block.256"] = new Block( glm::vec3(12.680147,26.959595,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_2["Block.257"] = new Block( glm::vec3(10.640425,23.938881,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_2["Block.258"] = new Block( glm::vec3(12.705065,23.903885,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_2["Block.259"] = new Block( glm::vec3(8.155362,27.355381,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_2["Block.260"] = new Block( glm::vec3(8.695525,26.394009,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_2["Block.261"] = new Block( glm::vec3(7.839646,25.425175,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_2["Block.262"] = new Block( glm::vec3(6.954350,24.518951,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_2["Block.263"] = new Block( glm::vec3(7.077550,27.369377,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_2["Block.264"] = new Block( glm::vec3(7.346282,23.553120,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.265"] = new Block( glm::vec3(8.410097,23.553120,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_2["Block.266"] = new Block( glm::vec3(15.875298,27.375538,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.267"] = new Block( glm::vec3(16.415461,26.414165,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_2["Block.268"] = new Block( glm::vec3(15.559582,25.445332,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.269"] = new Block( glm::vec3(14.674286,24.539108,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_2["Block.270"] = new Block( glm::vec3(14.797485,27.389534,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.271"] = new Block( glm::vec3(15.066217,23.573277,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_2["Block.272"] = new Block( glm::vec3(16.130033,23.573277,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_2["Block.273"] = new Block( glm::vec3(20.221731,26.986996,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_2["Block.274"] = new Block( glm::vec3(20.255388,25.980736,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_2["Block.275"] = new Block( glm::vec3(20.231791,24.941586,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_2["Block.276"] = new Block( glm::vec3(20.232798,23.925243,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.277"] = new Block( glm::vec3(18.206081,27.020592,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_2["Block.278"] = new Block( glm::vec3(18.189283,26.029564,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_2["Block.279"] = new Block( glm::vec3(19.163513,25.357681,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
			}
		}
		
		if(currentLevel == 2)
		{
			// level 3 smile
			{
				level_3["Block.818"] = new Block( glm::vec3(0.199893,26.700188,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_3["Block.819"] = new Block( glm::vec3(-1.907190,26.122684,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_3["Block.820"] = new Block( glm::vec3(-3.108616,25.896000,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_3["Block.821"] = new Block( glm::vec3(-4.304644,25.423203,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_3["Block.822"] = new Block( glm::vec3(-5.467210,25.007614,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_3["Block.823"] = new Block( glm::vec3(-6.590915,24.325403,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_3["Block.824"] = new Block( glm::vec3(-7.897047,23.272942,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_3["Block.825"] = new Block( glm::vec3(-8.706633,22.463356,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_3["Block.826"] = new Block( glm::vec3(-9.419068,21.459469,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_3["Block.827"] = new Block( glm::vec3(-10.066737,20.455582,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_3["Block.828"] = new Block( glm::vec3(-10.455338,19.386929,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_3["Block.829"] = new Block( glm::vec3(-10.487721,18.091591,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_3["Block.830"] = new Block( glm::vec3(-10.325805,16.990555,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_3["Block.831"] = new Block( glm::vec3(-9.742903,15.759984,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_3["Block.832"] = new Block( glm::vec3(-8.998084,14.561797,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_3["Block.833"] = new Block( glm::vec3(-8.058965,13.395993,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_3["Block.834"] = new Block( glm::vec3(-6.828394,12.327340,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_3["Block.835"] = new Block( glm::vec3(-5.630207,11.452988,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_3["Block.836"] = new Block( glm::vec3(-4.464403,10.740552,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_3["Block.837"] = new Block( glm::vec3(-3.039531,10.028116,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_3["Block.838"] = new Block( glm::vec3(-1.614660,9.607132,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_3["Block.839"] = new Block( glm::vec3(-0.416473,9.153764,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_3["Block.840"] = new Block( glm::vec3(0.943631,9.574748,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_3["Block.841"] = new Block( glm::vec3(2.498036,10.060499,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_3["Block.842"] = new Block( glm::vec3(3.577484,10.915062,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_3["Block.843"] = new Block( glm::vec3(4.701909,11.567228,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_3["Block.844"] = new Block( glm::vec3(5.871311,12.489257,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_3["Block.845"] = new Block( glm::vec3(7.085690,13.478751,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_3["Block.846"] = new Block( glm::vec3(8.322557,14.513222,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_3["Block.847"] = new Block( glm::vec3(9.267075,15.457739,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_3["Block.848"] = new Block( glm::vec3(9.469471,16.717094,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_3["Block.849"] = new Block( glm::vec3(9.581913,18.021427,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_3["Block.850"] = new Block( glm::vec3(9.689857,20.391716,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_3["Block.851"] = new Block( glm::vec3(9.150133,21.498152,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_3["Block.852"] = new Block( glm::vec3(8.493468,22.613581,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_3["Block.853"] = new Block( glm::vec3(7.701874,23.549105,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_3["Block.854"] = new Block( glm::vec3(6.725873,24.300220,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_3["Block.855"] = new Block( glm::vec3(5.695899,25.006359,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_3["Block.856"] = new Block( glm::vec3(4.670424,25.456129,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_3["Block.857"] = new Block( glm::vec3(3.528008,25.847429,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_3["Block.858"] = new Block( glm::vec3(2.430569,26.319687,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_3["Block.859"] = new Block( glm::vec3(1.261168,26.490601,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_3["Block.860"] = new Block( glm::vec3(-3.758265,22.226780,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_3["Block.861"] = new Block( glm::vec3(-2.651831,22.010891,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_3["Block.862"] = new Block( glm::vec3(-1.572383,21.282263,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_3["Block.863"] = new Block( glm::vec3(-1.653342,20.229801,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_3["Block.864"] = new Block( glm::vec3(-2.759776,19.528160,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_3["Block.865"] = new Block( glm::vec3(-3.974155,19.393229,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_3["Block.866"] = new Block( glm::vec3(-5.188534,19.986925,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_3["Block.867"] = new Block( glm::vec3(-5.836203,21.066374,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_3["Block.868"] = new Block( glm::vec3(-5.026617,22.064863,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_3["Block.869"] = new Block( glm::vec3(3.204174,22.199793,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_3["Block.870"] = new Block( glm::vec3(4.310608,21.983904,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_3["Block.871"] = new Block( glm::vec3(5.390057,21.255276,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_3["Block.872"] = new Block( glm::vec3(5.309098,20.202814,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_3["Block.873"] = new Block( glm::vec3(4.202663,19.501173,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_3["Block.874"] = new Block( glm::vec3(2.988285,19.366241,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_3["Block.875"] = new Block( glm::vec3(1.773906,19.959938,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_3["Block.876"] = new Block( glm::vec3(1.126237,21.039387,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_3["Block.877"] = new Block( glm::vec3(1.935823,22.037876,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_3["Block.878"] = new Block( glm::vec3(-5.431410,15.453243,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_3["Block.879"] = new Block( glm::vec3(-4.432920,14.535712,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_3["Block.880"] = new Block( glm::vec3(-3.380459,13.780099,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_09.png" );
				level_3["Block.881"] = new Block( glm::vec3(-2.166080,13.294348,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_3["Block.882"] = new Block( glm::vec3(-1.032660,12.997499,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_3["Block.883"] = new Block( glm::vec3(0.046788,12.754623,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_3["Block.884"] = new Block( glm::vec3(1.261167,13.105444,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_3["Block.885"] = new Block( glm::vec3(2.394588,13.753113,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_3["Block.886"] = new Block( glm::vec3(3.474036,14.670644,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_3["Block.887"] = new Block( glm::vec3(4.634442,15.372285,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_3["Block.888"] = new Block( glm::vec3(-0.825583,26.511286,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_3["Block.889"] = new Block( glm::vec3(9.905747,19.393227,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_3["Block.890"] = new Block( glm::vec3(-11.227143,21.184210,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_05.png" );
				level_3["Block.891"] = new Block( glm::vec3(-12.495495,22.020782,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_3["Block.892"] = new Block( glm::vec3(-9.705122,23.353901,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_3["Block.893"] = new Block( glm::vec3(-10.973474,24.352390,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_3["Block.894"] = new Block( glm::vec3(-7.292556,25.485809,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_3["Block.895"] = new Block( glm::vec3(-8.291046,26.511286,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_3["Block.896"] = new Block( glm::vec3(-4.790396,26.664568,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_3["Block.897"] = new Block( glm::vec3(-5.357106,27.932919,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_3["Block.898"] = new Block( glm::vec3(-2.204038,27.337063,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_3["Block.899"] = new Block( glm::vec3(-2.500886,28.632401,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_3["Block.900"] = new Block( glm::vec3(0.388796,27.887581,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_3["Block.901"] = new Block( glm::vec3(0.307837,29.047987,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
				level_3["Block.902"] = new Block( glm::vec3(2.862348,27.480093,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_3["Block.903"] = new Block( glm::vec3(3.671934,28.802418,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_3["Block.904"] = new Block( glm::vec3(5.453024,26.643522,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_06.png" );
				level_3["Block.905"] = new Block( glm::vec3(6.289596,27.830915,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_02.png" );
				level_3["Block.906"] = new Block( glm::vec3(7.616417,25.406654,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_07.png" );
				level_3["Block.907"] = new Block( glm::vec3(8.668879,26.405144,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_3["Block.908"] = new Block( glm::vec3(9.599902,23.288237,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_04.png" );
				level_3["Block.909"] = new Block( glm::vec3(10.841268,24.070837,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_08.png" );
				level_3["Block.910"] = new Block( glm::vec3(10.823277,21.012398,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_01.png" );
				level_3["Block.911"] = new Block( glm::vec3(12.118615,21.498150,0.000000), glm::quat(1.000000,0.000000,0.000000,0.000000), "T_Block_03.png" );
			}
		}
			
	}
	
		
		
	glm::vec3 getRandomForwardVector() //получить рандомный вектор для запуска мяча
	{
		return glm::normalize(glm::vec3(glm::linearRand(-100,100), glm::linearRand(50,100), 0 ));
	}	
		
	bool checkIntersection(Set* intersector)
	{
		bool intersect = false;
		glm::vec2 bary;// = glm::vec2(1, 1);
		float dist = 0.0f;
		
		//этим параметром задаем, насколько близко можно приблизиться к поверхности, чтоб засчиталось касание
		float length = glm::length(forward * ballSpeed*float(TICK)/1000.0f)*1.15f;// + 0.1f; //расстояние до точки соприкосновения для зачета. Должно быть чуть больше чем смещение позиции сканирующего луча за один кадр
						
		for(auto triangle2 : intersector->AABB )
		{
			glm::mat3 triangle = triangle2;	
		
			triangle[0] = intersector->worldRotation * (triangle[0]) + intersector->worldLocation;	
			triangle[1] = intersector->worldRotation * (triangle[1]) + intersector->worldLocation;	
			triangle[2] = intersector->worldRotation * (triangle[2]) + intersector->worldLocation;
					
			glm::vec3 norm_rotated = glm::normalize(intersector->worldRotation * triangle2[3]); //повернутая нормаль треугольника
			
			float ang = glm::dot(-forward, norm_rotated) / ( glm::length(-forward) * glm::length(norm_rotated) ) ; //косинус угла между векторами, для оценки сонаправленности
					
			if (glm::intersectRayTriangle(actors["Ball"]->worldLocation+glm::vec3(0,0,0.1), forward, triangle[0], triangle[1], triangle[2], bary, dist) && dist > 0.0f && dist < length && ang > 0	)
			{			
				intersect = true; 
				
				forward = glm::reflect(forward, norm_rotated);
				
				//printVec3(actors["Ball"]->worldLocation)
				printVec3(forward)
				
				break;
			}
		}
		return intersect;
	}
	
	// главная распределяющая функция логики
	void update()
	{
		if(state == 0) //menu
		{	menu();	}
		
		if(state == 1) //game
		{	game();	}
		
		if(state == 2) //pause
		{	pause();	}
		
		if(state == 3) //pause
		{	empty();	}
				
		glfwGetWindowSize(engineWindow, &Cam.windowResolution.x, &Cam.windowResolution.y);
		//glfwSetWindowSize(engineWindow, windowResolution.x, windowResolution.y);
		
		
		
		
		
		
		for(auto act : actors) 
		{ 
			if(act.second->visible) 
			{
				act.second->update();
				act.second->render(ProjViewMatrix);
			}	
		}	
		
		for(auto act : level_1) 
		{ 
			if(act.second->visible) 
			{
				act.second->update();
				act.second->render(ProjViewMatrix);
			}	
		}
		
		for(auto act : level_2) 
		{ 
			if(act.second->visible) 
			{
				act.second->update();
				act.second->render(ProjViewMatrix);
			}	
		}
		
		for(auto act : level_3) 
		{ 
			if(act.second->visible) 
			{
				act.second->update();
				act.second->render(ProjViewMatrix);
			}	
		}
	
		Cam.update();
		Cam.render(Cam.ProjViewMatrix);
	}
	
	void updateCarriageSpeed()
	{
		gameplayCarriageSpeed = 23.0f*gameplaySpeedUp;
	}
	
	void updateBallSpeed()
	{
		ballSpeed = 15.0f*gameplaySpeedUp;
	}
	
	void updateBlocksCount()
	{
		if(currentLevel == 0)
		{
			blocksCount = 0;
			for( auto act:level_1)
			{
				if (act.second->collision) {blocksCount++;}
			}
		}


		if(currentLevel == 1)
		{
			blocksCount = 0;
			for( auto act:level_2)
			{
				if (act.second->collision) {blocksCount++;}
			}
		}
		
		if(currentLevel == 2)
		{
			blocksCount = 0;
			for( auto act:level_3)
			{
				if (act.second->collision) {blocksCount++;}
			}
		}		
		
		
		
	}
	
	void selectLevel()
	{
		//~ std::cout << "Flag 4\n";
		//~ //if(state == 0 || bNextLevel) //только если в меню или разрешена смена уровня
		//~ {
			//~ currentLevel = currentLevel < 2 ? currentLevel+1 : 0;
			
			//~ printVariable(currentLevel)
		
		
			//~ if(currentLevel == 0)
			//~ {
				//~ for(auto act:level_1)
				//~ {
					//~ act.second->visible = true;
					//~ act.second->collision = true;
				//~ }	
				//~ for(auto act:level_2)
				//~ {
					//~ act.second->visible = false;
					//~ act.second->collision = false;	
				//~ }
				//~ for(auto act:level_3)
				//~ {
					//~ act.second->visible = false;
					//~ act.second->collision = false;
				//~ }
			//~ }
			
			//~ if(currentLevel == 1)
			//~ {
				//~ for(auto act:level_1)
				//~ {
					//~ act.second->visible = false;
					//~ act.second->collision = false;
				//~ }	
				//~ for(auto act:level_2)
				//~ {
					//~ act.second->visible = true;
					//~ act.second->collision = true;	
				//~ }
				//~ for(auto act:level_3)
				//~ {
					//~ act.second->visible = false;
					//~ act.second->collision = false;
				//~ }
			//~ }
		
			//~ if(currentLevel == 2)
			//~ {
				//~ for(auto act:level_1)
				//~ {
					//~ act.second->visible = false;
					//~ act.second->collision = false;
				//~ }	
				//~ for(auto act:level_2)
				//~ {
					//~ act.second->visible = false;
					//~ act.second->collision = false;	
				//~ }
				//~ for(auto act:level_3)
				//~ {
					//~ act.second->visible = true;
					//~ act.second->collision = true;
				//~ }
			//~ }
		
			//~ printMessage("Level changed")
		//~ }
		//~ levelSelected = false;
		
		
	}
	
	void menu() //0
	{
		//printMessage("menu")
		
		//~ for(int i=0; i<100000000; i++) //искусственно занизить ФПС
		//~ {
			//~ int f = 212123525;
		//~ }
		
		//здесь основные изменения перемещения, согласовать с частотой кадров
		//std::cout << "tick " << TICK << std::endl; //миллисекунд между кадрами
		
		glUniform1f(glGetUniformLocation( Shaders.getObjectByName("defaultShader")->testShader, "coeff"), 0 );
		
		
		//здесь вращение, так же согласовать с частотой кадров
		
		if(glfwGetKey(engineWindow, GLFW_KEY_ENTER) && !enterPressed) 
		{ 
			Flow.CallSequence( {"takeStartPosition", takeStartPosition, this} ); 
			glUniform1f(glGetUniformLocation( Shaders.getObjectByName("defaultShader")->testShader, "coeff"), 0 );
			enterPressed = true; 
		}
		if(!glfwGetKey(engineWindow, GLFW_KEY_ENTER))
		{
			enterPressed = false; 
		}
		
		
		//обучающее управление каретки
		if(glfwGetKey(engineWindow, GLFW_KEY_A) && actors["Carriage"]->worldLocation.x > -23.5) 
		{	actors["Carriage"]->worldLocation.x -= gameplayCarriageSpeed*float(TICK)/1000.0f; }
		if(glfwGetKey(engineWindow, GLFW_KEY_D) && actors["Carriage"]->worldLocation.x < 23.5) 
		{	actors["Carriage"]->worldLocation.x += gameplayCarriageSpeed*float(TICK)/1000.0f; }
		actors["Carriage"]->worldRotation = glm::quat(1,0,0,0);
		if(glfwGetKey(engineWindow, GLFW_KEY_LEFT) ) 	
		{	actors["Carriage"]->worldRotation = angleAxis(glm::radians(15.0f), glm::vec3(0,0,1)); }
		if(glfwGetKey(engineWindow, GLFW_KEY_RIGHT) ) 	
		{	actors["Carriage"]->worldRotation = angleAxis(glm::radians(-15.0f), glm::vec3(0,0,1)); }
		
		
		
		
		//~ // смена уровня
		if(glfwGetKey(engineWindow, GLFW_KEY_SPACE) && !levelSelected)
		{
			levelSelected = true;
			
			//~ if( !levelSelected )
			//~ {
				reloadLevel();	
				//~ levelSelected = true;		
			//~ }
		}
		
		if(!glfwGetKey(engineWindow, GLFW_KEY_SPACE))
		{
			levelSelected = false;
		}
		
		
		//полет камеры вокруг центра сцены
		Cam.worldLocation = glm::vec3(0,15, 21) + glm::vec3(0, -15, 0)* glm::angleAxis(glm::radians(-menuRotationAngle), Cam.cameraUpVec);
		menuRotationAngle = menuRotationAngle < 359.0f ? menuRotationAngle+360.0f*float(TICK)/24000.0f : 0;
		
		glm::vec3 POV = Cam.worldLocation;
		glm::vec3 DOV = glm::vec3(0,15,0);
		glm::vec3 UP = Cam.cameraUpVec;
		ProjViewMatrix = configureProjMatrix(Cam.cameraFOV)*configureViewMatrix(POV, DOV, UP);
		//т.к. матрица lookAt строится вокруг конкретной точки направления взгляда, то для безопасности надо обновить кватернион ориентации вручную на ее основе
		Cam.worldRotation = glm::conjugate(glm::quat_cast( configureViewMatrix(POV, DOV, UP) ));		
	}
	
	
	void startNewGame()
	{
		//enterGame = false;
		//gameplayProcess = true;
		
		state = 1; // переходим в режим игры
		lives = 3;
		
		Cam.components["Heart_1"]->visible = true;
		Cam.components["Heart_2"]->visible = true;
		Cam.components["Heart_3"]->visible = true;
		
		Cam.components["Gameover"]->visible = false;
		
		Cam.components["MainMenu"]->visible = false;
		Cam.components["Failure"]->visible = false;
		Cam.components["Victory"]->visible = false;
		Cam.components["Hint"]->visible = false;
		
		//~ //мяч в исходное
		actors["Ball"]->worldLocation = glm::vec3(0,1,0);
		forward = getRandomForwardVector();
		gameplaySpeedUp = defaultGameplaySpeed;
		
		hasAutopilotBonus = false;
		actors["Ball"]->autoPilot = 0;
	}
	
	void continueGame()
	{
		printMessage("continueGame") 
		Cam.components["Failure"]->visible = false;
		Cam.components["Victory"]->visible = false;
		Cam.components["Hint"]->visible = false;
		glUniform1f(glGetUniformLocation( Shaders.getObjectByName("defaultShader")->testShader, "coeff"), 0 );
		
		//~ //carriageControl = false;
		state = 1; // возвращаемся в режим игры
		//~ //мяч в исходное
		//actors["Ball"]->worldLocation = glm::vec3(0,1,0);
		forward = getRandomForwardVector();
		gameplaySpeedUp = defaultGameplaySpeed;
		
		hasAutopilotBonus = false;
		actors["Ball"]->autoPilot = 0;
	}
	
	void pause() //2
	{
		//printMessage("pause")
		
		//~ Cam.components["Failure"]->visible = true;
		//~ gameplayProcess = false;
		
		
		
		
		//нажимаем энтер для продолжения
		if(glfwGetKey(engineWindow, GLFW_KEY_ENTER) && !enterPressed)// && lives > 0 ) 
		{ 
			if(blocksCount > 0) //если блоки еще остались
			{
				if(lives > 0)
				{
					//если жизней 0, значит gameover и нажатие энтера приведет к следующей попытке
					
				}
				else
				{
					//если жизней 0, значит gameover и нажатие энтера приведет к перезапуску всей сессии
					lives = 3;
					//levelSelected = false;
					currentLevel = currentLevel > 0 ? currentLevel-1 : 2;
					reloadLevel();
				}
				Flow.CallSequence( {"takeStartPosition", takeStartPosition, this} ); 
				glUniform1f(glGetUniformLocation( Shaders.getObjectByName("defaultShader")->testShader, "coeff"), 0 );
				Cam.components["Failure"]->visible = false;
				Cam.components["MainMenu"]->visible = false;
				Cam.components["Hint"]->visible = false;
				Cam.components["Victory"]->visible = false;
				
			}
			else //победа, идем на следующий уровень
			{
				printMessage("go to next level")
				//levelSelected = false;
				reloadLevel();
				//state = 1; //в игру
				//startNewGame();
				glUniform1f(glGetUniformLocation( Shaders.getObjectByName("defaultShader")->testShader, "coeff"), 0 );
				Flow.CallSequence( {"takeStartPosition", takeStartPosition, this} ); 
				
			}
			
			
			
			
			
			
			//~ Flow.CallSequence( {"takeStartPosition", takeStartPosition, this} ); 
			//~ glUniform1f(glGetUniformLocation( Shaders.getObjectByName("defaultShader")->testShader, "coeff"), 0 );
			//~ enterPressed = true; 
			//~ Cam.components["Failure"]->visible = false;
			//~ Cam.components["MainMenu"]->visible = false;
			
			
			
			//~ if(bNextLevel)
			//~ {
				//~ printMessage("go to next level")
				//~ //currentLevel = currentLevel < 2 ? currentLevel+1 : 0;
				//~ //loadLevels();
				//~ //loadLevels();
				//~ //changeLevel();
			//~ }
		}
		
		
		if(!glfwGetKey(engineWindow, GLFW_KEY_ENTER) )
		{	 enterPressed = false; }		
		
		
		//~ //выход в главное меню
		if(glfwGetKey(engineWindow, GLFW_KEY_SPACE) && ! spacePressed)
		{
			spacePressed = true;
			state = 0;	
			Cam.components["Gameover"]->visible = false;
			Cam.components["Failure"]->visible = false;
			Cam.components["Victory"]->visible = false;
			Cam.components["MainMenu"]->visible = true;
			
			Cam.components["Heart_1"]->visible = false;
			Cam.components["Heart_2"]->visible = false;
			Cam.components["Heart_3"]->visible = false;
			
			glUniform1f(glGetUniformLocation( Shaders.getObjectByName("defaultShader")->testShader, "coeff"), 0 );
			
			menuRotationAngle = 0;
			//reloadLevels(); //перезагрузка уровней
			lives = 3;
		}
		
		if(!glfwGetKey(engineWindow, GLFW_KEY_SPACE))
		{
			spacePressed = false;
		}
		
		
		//~ if(lives == 0)
		//~ {
			//~ printMessage("Game over!!")
		//~ }
		
	}
	
	void gameOver()
	{
		printMessage("Game over")
		state = 2;//pause
		Cam.components["Gameover"]->visible = true;
		Cam.components["Failure"]->visible = false;
	}
	
	void failure()
	{
		printMessage("Failure")
		state = 2;//pause
		Cam.components["Gameover"]->visible = false;
		Cam.components["Failure"]->visible = true; 
	}
	
	void victory()
	{
		printMessage("Congratulations! Play again? Y(Enter)/N(ESC)")
		state = 2; //pause
		Cam.components["Victory"]->visible = true;
		Cam.components["Failure"]->visible = false;
		Cam.components["Gameover"]->visible = false;
	}
	
	void calculateSimulation(Set* act)
	{
		//Weapon* wpn = dynamic_cast<Weapon*>(currentLevel->getTaggedActorNearPoint("Weapon", PLAYER->worldLocation));
		Block* blk = dynamic_cast<Block*>(act);
		
		if(blk!=nullptr)
		{
			//printMessage(act.first) 
			
			fieldWatchDog = 0;
			
			Flow.CallSequence( {"blowBlock", blk->blowBlock, blk} );
			
			if(act->components["Block_cell"]->entityTextureName == "T_Block_01.png")
			{
				printMessage("Crash a red!")
				actors["Ball"]->haveBonus = 1;
				Flow.CallSequence({"showHint",Cam.showHint, &Cam});
			} 
			
			
			if(act->components["Block_cell"]->entityTextureName == "T_Block_03.png")
			{
				printMessage("Crash a blue!")
				//actors["Ball"]->haveBonus = 1;
				hasAutopilotBonus = true;
				Flow.CallSequence({"showHint",Cam.showHint, &Cam});
				
			}
			//gameplaySpeedUp += 0.05f;
			
			//сменим цвет мяча
			//actors["Ball"]->components["Ball_01"]->entityColor = blk->components["Block_cell"]->entityColor;
		}
	}
	
	void game() //1
	{
		//printMessage("game")
		
		
		//~ for(int i=0; i<30000000; i++) //искусственно занизить ФПС
		//~ {
			//~ int f = 212123525;
		//~ }
		
		//здесь основные изменения перемещения, согласовать с частотой кадров
		//std::cout << "tick " << TICK << std::endl; //миллисекунд между кадрами
			
		//if(glfwGetKey(engineWindow, GLFW_KEY_SPACE)) { state = 0; menuRotationAngle = 0; carriageControl = false;}
		
	
		updateCarriageSpeed();
		updateBallSpeed();
		updateBlocksCount();
		
		printMessage(blocksCount)
		
		//ручное перемещение мяча
		//~ if(glfwGetKey(engineWindow, GLFW_KEY_W) ) {	actors["Ball"]->worldLocation.y += 8*float(TICK)/1000.0f; }
		//~ if(glfwGetKey(engineWindow, GLFW_KEY_S) ) {	actors["Ball"]->worldLocation.y -= 8*float(TICK)/1000.0f; }
		//~ if(glfwGetKey(engineWindow, GLFW_KEY_A) ) {	actors["Ball"]->worldLocation.x -= 8*float(TICK)/1000.0f; }
		//~ if(glfwGetKey(engineWindow, GLFW_KEY_D) ) {	actors["Ball"]->worldLocation.x += 8*float(TICK)/1000.0f; }
		
		//игровое перемещение объектов
		actors["Ball"]->worldLocation += forward * ballSpeed*float(TICK)/1000.0f;
		if(glfwGetKey(engineWindow, GLFW_KEY_A) && actors["Carriage"]->worldLocation.x > -23.5) {	actors["Carriage"]->worldLocation.x -= gameplayCarriageSpeed*float(TICK)/1000.0f; }
		if(glfwGetKey(engineWindow, GLFW_KEY_D) && actors["Carriage"]->worldLocation.x < 23.5) {	actors["Carriage"]->worldLocation.x += gameplayCarriageSpeed*float(TICK)/1000.0f; }
		actors["Carriage"]->worldRotation = glm::quat(1,0,0,0);
		if(glfwGetKey(engineWindow, GLFW_KEY_LEFT) ) 	{	actors["Carriage"]->worldRotation = angleAxis(glm::radians(15.0f), glm::vec3(0,0,1)); }
		if(glfwGetKey(engineWindow, GLFW_KEY_RIGHT) ) 	{	actors["Carriage"]->worldRotation = angleAxis(glm::radians(-15.0f), glm::vec3(0,0,1)); }
		
		if( actors["Ball"]->autoPilot == 1) {actors["Carriage"]->worldLocation.x = actors["Ball"]->worldLocation.x;} //автопилот
						
		//Cam.worldLocation = glm::vec3(0,15, 21) + glm::vec3(0, -15, 0)* glm::angleAxis(glm::radians(-menuRotationAngle), Cam.cameraUpVec);
		//menuRotationAngle = menuRotationAngle < 359.0f ? menuRotationAngle+360.0f*float(TICK)/12000.0f : 0;
		
		actors["Ball"]->worldRotation *= glm::angleAxis(glm::radians(360.0f*float(TICK)/6000.0f), forward);
		
		glm::vec3 POV = Cam.worldLocation;
		glm::vec3 DOV = POV + Cam.cameraVectorsForwardAndRight[0];
		glm::vec3 UP = Cam.cameraUpVec;		
		ProjViewMatrix = configureProjMatrix(Cam.cameraFOV)*configureViewMatrix(POV, DOV, UP);//;// * ; glm::mat4(1.0);//
		
		// failure: ball outside
		if(actors["Ball"]->worldLocation.y < -0.1 ) 
		{ 
			printMessage("You lose! Try again? Y(Enter)/N(ESC)") 
			
			printVec3(actors["Ball"]->worldLocation)
		
			if(lives == 3) Cam.components["Heart_3"]->visible = false;
			if(lives == 2) Cam.components["Heart_2"]->visible = false;
			if(lives == 1) Cam.components["Heart_1"]->visible = false;
			lives--;
			
			Flow.CallSequence( {"loseSession", loseSession, this} );
			
			//failure visible
			if(lives >= 1) 
			{ failure(); }
			else { gameOver(); }
			//enterPressed = false;
		}
		
		
		if(actors["Ball"]->worldLocation.x < -26 || actors["Ball"]->worldLocation.x > 26 || actors["Ball"]->worldLocation.y > 30)
		{
			printMessage("ERROR! Ball outside! Y(Enter)/N(ESC)") 
			printVec3(actors["Ball"]->worldLocation)
			
			//state = 2;
			//enterPressed = false;
			actors["Ball"]->worldLocation -= forward *1.5f * ballSpeed*float(TICK)/1000.0f;
			forward = glm::angleAxis(glm::radians(10.0f), glm::vec3(0,0,1)) * forward;
		}
		
		
		
		if(glfwGetKey(engineWindow, GLFW_KEY_F) && actors["Ball"]->haveBonus == 1)
		{
			destroySetsInRadius();
			actors["Ball"]->haveBonus = 0;
		}
		
		if(glfwGetKey(engineWindow, GLFW_KEY_E) && hasAutopilotBonus)
		{
			hasAutopilotBonus = false;
			Flow.CallSequence({"enableAutopilot",enableAutopilot, this});
		}
		
		
		
		if(blocksCount == 0)
		{
			victory();
			
			
			//enterPressed = false;
			//bNextLevel = true;
		}
		
		if(glfwGetKey(engineWindow, GLFW_KEY_SPACE) && ! spacePressed)
		{
			spacePressed = true;
			state = 0;	
			Cam.components["Gameover"]->visible = false;
			Cam.components["Failure"]->visible = false;
			Cam.components["Victory"]->visible = false;
			Cam.components["MainMenu"]->visible = true;
			
			Cam.components["Heart_1"]->visible = false;
			Cam.components["Heart_2"]->visible = false;
			Cam.components["Heart_3"]->visible = false;
			
			glUniform1f(glGetUniformLocation( Shaders.getObjectByName("defaultShader")->testShader, "coeff"), 0 );
			
			menuRotationAngle = 0;
			//reloadLevels(); //перезагрузка уровней
			lives = 3;
		}
		
		if(!glfwGetKey(engineWindow, GLFW_KEY_SPACE))
		{
			spacePressed = false;
		}
		
		
		//разборка с коллизиями
		for (auto act:actors)
		{
			if(checkIntersection(act.second))
			{
				//printMessage(act.first) 
				fieldWatchDog++;
				
				if(fieldWatchDog > 2)
				{
					forward = glm::angleAxis(glm::radians(10.0f), glm::vec3(0,0,1)) * forward;
				}
			}
		}
		
		if(currentLevel == 0)
		{
			for (auto act:level_1)
			{		
				if(act.second->collision && checkIntersection(act.second) ) 
				{
					calculateSimulation(act.second);
					//~ //Weapon* wpn = dynamic_cast<Weapon*>(currentLevel->getTaggedActorNearPoint("Weapon", PLAYER->worldLocation));
					//~ Block* blk = dynamic_cast<Block*>(act.second);
					
					//~ if(blk!=nullptr)
					//~ {
						//~ //printMessage(act.first) 
						
						//~ fieldWatchDog = 0;
						
						//~ Flow.CallSequence( {"blowBlock", blk->blowBlock, blk} );
						
						//~ //gameplaySpeedUp += 0.05f;
						
						//~ //сменим цвет мяча
						//~ //actors["Ball"]->components["Ball_01"]->entityColor = blk->components["Block_cell"]->entityColor;
					//~ }
					break;
				}
				
			}
		}
		
		if(currentLevel == 1)
		{
			for (auto act:level_2)
			{		
				if(act.second->collision && checkIntersection(act.second) ) 
				{
					calculateSimulation(act.second);
					//Weapon* wpn = dynamic_cast<Weapon*>(currentLevel->getTaggedActorNearPoint("Weapon", PLAYER->worldLocation));
					//~ Block* blk = dynamic_cast<Block*>(act.second);
					
					//~ if(blk!=nullptr)
					//~ {
						//~ //printMessage(act.first) 
						
						//~ fieldWatchDog = 0;
						
						//~ Flow.CallSequence( {"blowBlock", blk->blowBlock, blk} );
						
						//~ //gameplaySpeedUp += 0.05f;
						
						//~ //сменим цвет мяча
						//~ //actors["Ball"]->components["Ball_01"]->entityColor = blk->components["Block_cell"]->entityColor;
					//~ }
					break;
				}
			}
		}
		
		if(currentLevel == 2)
		{
			for (auto act:level_3)
			{		
				if(act.second->collision && checkIntersection(act.second) ) 
				{
					calculateSimulation(act.second);
					break;
				}	
			}
		}
		
			
	}
	
	void empty() //3
	{
		//printMessage("empty")
		
		glm::vec3 POV = Cam.worldLocation;
		glm::vec3 DOV = POV + Cam.cameraVectorsForwardAndRight[0];
		glm::vec3 UP = Cam.cameraUpVec;
		
		//POV -= glm::vec3(0,0,7);
		//DOV = actors["Ball"]->worldLocation;
		
		ProjViewMatrix = configureProjMatrix(Cam.cameraFOV)*configureViewMatrix(POV, DOV, UP);//;// * ; glm::mat4(1.0);//
	}
	
	
	
	
	static bool takeStartPosition(void* ptr) //временнАя последовательность, которая описывает плавное перемещение камеры в основную игровую позицию
	{
		static int timer = 0;
		
		#define DURATION 120

		static glm::vec3 inputOrigin = glm::vec3(0, 0, 0); //запомнить координаты, в которых находился игрок перед взаимодействием с лифтом
		static glm::quat inputQuat = glm::quat(1, 0, 0, 0);
		static glm::vec3 inputCarriageVec = glm::vec3(0,0,0);
		
		static glm::vec3 inputBallVec = glm::vec3(0,0,0);

		glm::vec3 scriptStartPoint = glm::vec3(0, 3.6, 21);
		glm::quat scriptStartQuat = glm::quat(0.980, 0.2, 0, 0);
		
		//~ glm::vec4 scriptStartPoint = glm::vec4(-4.697, 8.81, 3.46, 1);
		//~ glm::quat scriptStartQuat = glm::quat(0.958, 0.281, -0.014, -0.048);

		if (timer == 0) //в самом начале установим игрока в нужную точку
		{
			GAME->Cam.components["MainMenu"]->visible = false;
			GAME->Cam.components["Gameover"]->visible = false;
			//Cam.components["Failure"]->visible = false;
			//GAME->enterPressed = false;
			
			glUniform1f(glGetUniformLocation( Shaders.getObjectByName("defaultShader")->testShader, "coeff"), 0);
			
			GAME->state = 3; //пустое вспомогательное состояние
			inputOrigin = GAME->Cam.worldLocation;	//запомнить положение камеры
			//inputQuat = GAME->Cam.worldRotation;
			
			glm::vec3 POV = GAME->Cam.worldLocation;
			glm::vec3 DOV = glm::vec3(0,7.5,0);
				//DOV = POV + cameraVectorsForwardAndRight[0];
			glm::vec3 UP = GAME->Cam.cameraUpVec;
			
			inputQuat = glm::conjugate(glm::quat_cast( GAME->configureViewMatrix(POV, DOV, UP) )); //вычислить кватернион на основе матрицы
		
			inputCarriageVec = GAME->actors["Carriage"]->worldLocation;	//запомнить положение каретки
			
			inputBallVec = GAME->actors["Ball"]->worldLocation; //запомнить положение мяча
			
		}

		if (timer <= DURATION) //N кадров плавно подводим к точке старта
		{
			//std::cout << "moving" << std::endl;
			
			float coeff = timer / float(DURATION);
			
			//glm::vec4 bl4 = blendVectors4(glm::vec4(inputOrigin[0], inputOrigin[1], inputOrigin[2], 1), scriptStartPoint, coeff);
			
			GAME->Cam.worldLocation = glm::mix(inputOrigin, scriptStartPoint, coeff ); //glm::vec3( bl4[0], bl4[1], bl4[2] ) ;
			GAME->Cam.worldRotation = blendQuat(inputQuat, scriptStartQuat, coeff);
			
			//glm::vec4 bl41 = blendVectors4(glm::vec4(inputCarriageVec[0], inputCarriageVec[1], inputCarriageVec[2], 1), glm::vec4(0,0,0,0), coeff);
			GAME->actors["Carriage"]->worldLocation = glm::mix(inputCarriageVec, glm::vec3(0,0,0), coeff ); //glm::vec3( bl41[0], bl41[1], bl41[2] ) ;
			GAME->actors["Ball"]->worldLocation = glm::mix(inputBallVec, glm::vec3(0,1,0), coeff ); //glm::vec3( bl41[0], bl41[1], bl41[2] ) ;
			
			glUniform1f(glGetUniformLocation( Shaders.getObjectByName("defaultShader")->testShader, "coeff"), 0);
		}
	
		
		if (timer == DURATION)
		{
			//~ GAME->enterGame = false;
			//~ GAME->carriageControl = true;
			
			//GAME->startNewGame();
			
			//GAME->bChangeLevel = false;
			
			//здесь надо уточнять, в какое состояние переводить
			
			if (GAME->lives == 3) //если итерация - первая (новая игра)
			{
				//GAME->state = 1;
				GAME->startNewGame();
			}
			else
			{
				//GAME->state = 3;
				GAME->continueGame();
			}
			
			//~ if(GAME->bNextLevel)
			//~ {
				//~ //GAME->changeLevel();
				//~ GAME->bNextLevel = false;
			//~ }
			
			timer = 0; 	return true;
		}
		else
		{
			timer++;	return false;
		}

	}
	
	
	static bool loseSession(void* ptr) //временнАя последовательность, которая описывает закрашивание экрана красным в случае поражения
	{
		static int timer = 0;
		static int duration = 2*1000/TICK ;
		//#define DURATION 5*1000/GAME->TICK 
		//количество кадров на 5 секунд 
		
		if (timer == 0) //в самом начале установим игрока в нужную точку
		{
			duration = 2*1000/TICK;
		}

		if (timer <= duration) //первые N кадров плавно подводим к точке старта
		{
			//std::cout << "coloring " << float(timer)/float(duration) << std::endl;
			//плавно изменять вектор цветовой заливки окна
			glUniform1f(glGetUniformLocation( Shaders.getObjectByName("defaultShader")->testShader, "coeff"), float(timer)/float(duration) );
		}
	
		if (timer == duration)
		{
			timer = 0; 	return true;
		}
		else
		{	timer++;	return false;	}
	}
	
	
	static bool enableAutopilot(void* ptr) //временнАя последовательность, которая описывает плавное перемещение камеры в основную игровую позицию
	{
		static int timer = 0;
		
		#define DURATION 1200

		if (timer == 0) //в самом начале установим игрока в нужную точку
		{
			GAME->actors["Ball"]->autoPilot = 1;
		}
		
		if (timer == DURATION)
		{
			GAME->actors["Ball"]->autoPilot = 0;
			timer = 0; 	return true;
		}
		else
		{
			timer++;	return false;
		}

	}
	
	
	glm::mat4 configureProjMatrix(GLfloat FOV)//просчитываем матрицы для рендера с точки зрения камеры
	{
		glm::mat4 ProjMatrix = glm::mat4(1.0);
		GLfloat ratio = float(Cam.windowResolution.x) / float(Cam.windowResolution.y); //windowResolution.x / windowResolution.y;    //ratio - соотношение
		ProjMatrix = glm::perspective(glm::radians(FOV), ratio, 0.01f, 7000.0f);
		
		//ProjMatrix = glm::ortho(0.0f, 1.0f*float(Cam.windowResolution.x), 0.0f, 1.0f*float(Cam.windowResolution.y), 0.01f, 70.0f );
			
		//ProjMatrix = glm::ortho(-0.5f*float(Cam.windowResolution.x), 0.5f*float(Cam.windowResolution.x), -0.5f*float(Cam.windowResolution.y), 0.5f*float(Cam.windowResolution.y), 0.01f, 70.0f );
		//ProjMatrix = glm::ortho(-0.5f*ratio, 0.5f*ratio, -0.5f*ratio, 0.5f*ratio, 0.01f, 70.0f );
		//ProjMatrix = glm::ortho(-1.0f, 1.0f, -1.0f * float(Cam.windowResolution.x)/float(Cam.windowResolution.y), 1.0f*float(Cam.windowResolution.x)/float(Cam.windowResolution.y), 0.01f, 7000.0f );
		return ProjMatrix;
	}

	glm::mat4 configureViewMatrix(glm::vec3 POV, glm::vec3 DOV, glm::vec3 UP)//просчитываем матрицы для рендера с точки зрения камеры
	{
		glm::mat4 ViewMatrix = glm::mat4(1.0);
		ViewMatrix = glm::lookAt(POV, //позиция точки наблюдения
								DOV, //направление наблюдения
								UP); //направление вверх
		return ViewMatrix;
	}

	
	void mainLoop()
	{
		since_last_call(); // initialize functions internal static time_point
		
		while (!glfwWindowShouldClose(engineWindow))
		{
			if(glfwGetKey(engineWindow, GLFW_KEY_ESCAPE)) { glfwSetWindowShouldClose(engineWindow, GLFW_TRUE);  }
			
			glfwPollEvents();

			glViewport(0, 0, Cam.windowResolution.x, Cam.windowResolution.y);
			glClearColor(0.1f, 0.1, 0.1f, 0.0f);   //задаем значение цвета. Т.е. функция устанавливающая состояние
			glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //очищаем экран, заполнив буфера цвета и глубины заданными значениями. Т.е. функция использующая состояние, которая использует состояние для определения цвета заполнения экрана.
			
						
			//Cam.update();
			
			Flow.Execute();	//глобальный класс, подмешивающий в поток цикла привязанные функции. Однократно
			
			update();
			

			glfwSwapBuffers(engineWindow);
			
			// print out the number of milliseconds
			milliseconds ms = since_last_call();
			//std::cout << "time passed: " << ms.count() << " milliseconds.\n";
			TICK = ms.count();
		}
		
		
	}
	
	bool coreCreateWindowGL()
	{
		glfwInit();
		glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
		glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
		glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
		glfwWindowHint(GLFW_RESIZABLE, GL_TRUE);

		engineWindow = glfwCreateWindow(Cam.windowResolution.x, Cam.windowResolution.y, "Arkanoid2024(@indoostrialniy)", glfwGetPrimaryMonitor(), nullptr); // glfwGetPrimaryMonitor()

		if (engineWindow == nullptr) { printMessage("Failed to create GLFW window") glfwTerminate(); return false; }

		glfwMakeContextCurrent(engineWindow);

		glfwSetWindowPos(engineWindow, 100, 200);


		glEnable(GL_DEPTH_TEST);
		glEnable(GL_CULL_FACE);

		if (glewInit() != GLEW_OK) { printMessage("Failed to initialize GLEW") return false; }
		else { return true; }

	}
	
	
	void cleanup()
	{
		glfwDestroyWindow(engineWindow);
		
		glfwTerminate();
		
		
	}
	
	
	milliseconds since_last_call()
	{
		// retain time between calls (static)
		static hr_time_point previous = hr_clock::now();

		// get current time
		hr_time_point current = hr_clock::now();

		// get the time difference between now and previous call to the function
		milliseconds ms = std::chrono::duration_cast<milliseconds>(current - previous);

		// store current time for next call
		previous = current;

		// return elapsed time in milliseconds
		return ms;
	}
	
public:

	//~ Arkanoid()
	//~ {
		//~ coreCreateWindowGL();	//подтянуть OpenGL
	//~ }
	void run()
	{	
		coreCreateWindowGL();	//подтянуть OpenGL
		
		printMessage("Load level")
		//загрузить уровень и ассеты
		
		loadEnvironment();
		
		Cam.init();
		
		
		
		//reloadLevels();
		
		reloadLevel();
		
		mainLoop();
		
		cleanup();
	}
	
	~Arkanoid()
	{
		for(auto act : actors) { delete act.second;}	//очистка всех Set* через их собственные деструкторы
		actors.clear();									//очистка словаря игровых объектов
		
		for(auto act : level_1) { delete act.second;}	//очистка всех Set* через их собственные деструкторы
		level_1.clear();									//очистка словаря игровых объектов
		
		for(auto act : level_2) { delete act.second;}	//очистка всех Set* через их собственные деструкторы
		level_2.clear();									//очистка словаря игровых объектов
		
	}
};


int main()
{
	printMessage("Seletion task for Sineus hackaton by @indoostrialniy")
	
	Arkanoid myGame;
	
	myGame.run();
	
	printMessage("It`s all, thanks!")
	return 0;
}
